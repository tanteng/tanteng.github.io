<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>Laravel构造函数自动依赖注入 &middot; TonyTan</title>

  
  <link rel="stylesheet" href="http://tanteng.me/css/poole.css">
  <link rel="stylesheet" href="http://tanteng.me/css/hyde.css">
  <link rel="stylesheet" href="http://tanteng.me/css/poole-overrides.css">
  <link rel="stylesheet" href="http://tanteng.me/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://tanteng.me/css/hyde-x.css">
  <link rel="stylesheet" href="http://tanteng.me/css/highlight/sunburst.css">
  
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://tanteng.me/touch-icon-144-precomposed.png">
  <link href="http://tanteng.me/favicon.png" rel="icon">

  
  
  
  

  <meta name="description" content="Your default page description">
  <meta name="keywords" content="your,default,page,keywords">
  
</head>
<body class="theme-base-0d">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://tanteng.me/"><h1>小谈博客</h1></a>
      <p class="lead">
       一个专注WEB技术的博客 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://tanteng.me/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="https://github.com/tanteng"><i class="fa fa-github fa-3x"></i></a>
      
      
      <a href="https://www.linkedin.com/in/tanteng"><i class="fa fa-linkedin-square fa-3x"></i></a>
      <a href="https://www.instagram.com/tanteng1031"><i class="fa fa-instagram fa-3x"></i></a>
      <a href="https://www.facebook.com/tanteng001"><i class="fa fa-facebook-square fa-3x"></i></a>
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2019 <a href="http://tanteng.me/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>

  </div>
</div>


<div class="content container">
  <div class="post">
    <h1 class="post-title">Laravel构造函数自动依赖注入</h1>
    <span class="post-date">Jan 28, 2016 &middot; 2 minute read
    
    <br/>
    <a class="label" href="http://tanteng.me/categories/develop">Develop</a><a class="label" href="http://tanteng.me/categories/laravel">Laravel</a><a class="label" href="http://tanteng.me/categories/php">PHP</a>
    </span>
    <p>在Laravel的构造函数中可以实现自动依赖注入，而不需要实例化之前先实例化需要的类，如代码所示：</p>

<pre class="lang:php decode:true ">&lt;?php
namespace Lio\Http\Controllers\Forum;

use Lio\Forum\Replies\ReplyRepository;
use Lio\Forum\Threads\ThreadCreator;
use Lio\Forum\Threads\ThreadCreatorListener;
use Lio\Forum\Threads\ThreadDeleterListener;
use Lio\Forum\Threads\ThreadForm;
use Lio\Forum\Threads\ThreadRepository;
use Lio\Forum\Threads\ThreadUpdaterListener;
use Lio\Http\Controllers\Controller;
use Lio\Tags\TagRepository;


class ForumThreadsController extends Controller implements ThreadCreatorListener, ThreadUpdaterListener, ThreadDeleterListener
{
    protected $threads;
    protected $tags;
    protected $currentSection;
    protected $threadCreator;

    public function __construct(
        ThreadRepository $threads,
        ReplyRepository $replies,
        TagRepository $tags,
        ThreadCreator $threadCreator
    ) {
        $this-&gt;threads = $threads;
        $this-&gt;tags = $tags;
        $this-&gt;threadCreator = $threadCreator;
        $this-&gt;replies = $replies;
    }
}</pre>

<p>注意构造函数中的几个类型约束，其实并没有地方实例化这个Controller并把这几个类型的参数传进去，Laravel会自动检测类的构造函数中的类型约束参数，并自动识别是否初始化并传入。</p>

<p>源码vendor/illuminate/container/Container.php中的build方法：</p>

<pre class="lang:php decode:true ">$constructor = $reflector-&gt;getConstructor();
dump($constructor);</pre>

<p>这里会解析类的构造函数，在这里打印看：</p>

<p><img class="alignnone size-full wp-image-9469" src="https://blog.tanteng.me/wp-content/uploads/2016/01/reflection_construct.png" alt="reflection_construct" width="430" height="194" /></p>

<p>它会找出构造函数的参数，再看完整的build方法进行的操作：</p>

<pre class="lang:php decode:true ">public function build($concrete, array $parameters = [])
{
    // If the concrete type is actually a Closure, we will just execute it and
    // hand back the results of the functions, which allows functions to be
    // used as resolvers for more fine-tuned resolution of these objects.
    if ($concrete instanceof Closure) {
        return $concrete($this, $parameters);
    }

    $reflector = new ReflectionClass($concrete);

    // If the type is not instantiable, the developer is attempting to resolve
    // an abstract type such as an Interface of Abstract Class and there is
    // no binding registered for the abstractions so we need to bail out.
    if (! $reflector-&gt;isInstantiable()) {
        $message = "Target [$concrete] is not instantiable.";

        throw new BindingResolutionContractException($message);
    }

    $this-&gt;buildStack[] = $concrete;

    $constructor = $reflector-&gt;getConstructor();

    // If there are no constructors, that means there are no dependencies then
    // we can just resolve the instances of the objects right away, without
    // resolving any other types or dependencies out of these containers.
    if (is_null($constructor)) {
        array_pop($this-&gt;buildStack);

        return new $concrete;
    }

    $dependencies = $constructor-&gt;getParameters();

    // Once we have all the constructor's parameters we can create each of the
    // dependency instances and then use the reflection instances to make a
    // new instance of this class, injecting the created dependencies in.
    $parameters = $this-&gt;keyParametersByArgument(
        $dependencies, $parameters
    );

    $instances = $this-&gt;getDependencies(
        $dependencies, $parameters
    );

    array_pop($this-&gt;buildStack);

    return $reflector-&gt;newInstanceArgs($instances);
}</pre>

<p>具体从容器中获取实例的方法：</p>

<pre class="lang:php decode:true ">protected function resolveClass(ReflectionParameter $parameter)
{
    try {
        return $this-&gt;make($parameter-&gt;getClass()-&gt;name);
    }

    // If we can not resolve the class instance, we will check to see if the value
    // is optional, and if it is we will return the optional parameter value as
    // the value of the dependency, similarly to how we do this with scalars.
    catch (BindingResolutionContractException $e) {
        if ($parameter-&gt;isOptional()) {
            return $parameter-&gt;getDefaultValue();
        }

        throw $e;
    }
}</pre>

<p>框架底层通过Reflection反射为开发节省了很多细节，实现了自动依赖注入。</p>
  </div>
  
</div>




<script src="http://tanteng.me/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

