<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.55.6" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Laravel构造函数自动依赖注入 &middot; 小谈博客</title>

  
  <link type="text/css" rel="stylesheet" href="https://tanteng.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://tanteng.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://tanteng.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://tanteng.github.io/css/hyde.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://tanteng.github.io/"><h1>小谈博客</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://tanteng.github.io/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2019. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Laravel构造函数自动依赖注入</h1>
  <time datetime=2016-01-28T05:59:41Z class="post-date">Thu, Jan 28, 2016</time>
  <p>在Laravel的构造函数中可以实现自动依赖注入，而不需要实例化之前先实例化需要的类，如代码所示：</p>

<pre class="lang:php decode:true ">&lt;?php
namespace Lio\Http\Controllers\Forum;

use Lio\Forum\Replies\ReplyRepository;
use Lio\Forum\Threads\ThreadCreator;
use Lio\Forum\Threads\ThreadCreatorListener;
use Lio\Forum\Threads\ThreadDeleterListener;
use Lio\Forum\Threads\ThreadForm;
use Lio\Forum\Threads\ThreadRepository;
use Lio\Forum\Threads\ThreadUpdaterListener;
use Lio\Http\Controllers\Controller;
use Lio\Tags\TagRepository;


class ForumThreadsController extends Controller implements ThreadCreatorListener, ThreadUpdaterListener, ThreadDeleterListener
{
    protected $threads;
    protected $tags;
    protected $currentSection;
    protected $threadCreator;

    public function __construct(
        ThreadRepository $threads,
        ReplyRepository $replies,
        TagRepository $tags,
        ThreadCreator $threadCreator
    ) {
        $this-&gt;threads = $threads;
        $this-&gt;tags = $tags;
        $this-&gt;threadCreator = $threadCreator;
        $this-&gt;replies = $replies;
    }
}</pre>

<p>注意构造函数中的几个类型约束，其实并没有地方实例化这个Controller并把这几个类型的参数传进去，Laravel会自动检测类的构造函数中的类型约束参数，并自动识别是否初始化并传入。</p>

<p>源码vendor/illuminate/container/Container.php中的build方法：</p>

<pre class="lang:php decode:true ">$constructor = $reflector-&gt;getConstructor();
dump($constructor);</pre>

<p>这里会解析类的构造函数，在这里打印看：</p>

<p><img class="alignnone size-full wp-image-9469" src="https://blog.tanteng.me/wp-content/uploads/2016/01/reflection_construct.png" alt="reflection_construct" width="430" height="194" /></p>

<p>它会找出构造函数的参数，再看完整的build方法进行的操作：</p>

<pre class="lang:php decode:true ">public function build($concrete, array $parameters = [])
{
    // If the concrete type is actually a Closure, we will just execute it and
    // hand back the results of the functions, which allows functions to be
    // used as resolvers for more fine-tuned resolution of these objects.
    if ($concrete instanceof Closure) {
        return $concrete($this, $parameters);
    }

    $reflector = new ReflectionClass($concrete);

    // If the type is not instantiable, the developer is attempting to resolve
    // an abstract type such as an Interface of Abstract Class and there is
    // no binding registered for the abstractions so we need to bail out.
    if (! $reflector-&gt;isInstantiable()) {
        $message = "Target [$concrete] is not instantiable.";

        throw new BindingResolutionContractException($message);
    }

    $this-&gt;buildStack[] = $concrete;

    $constructor = $reflector-&gt;getConstructor();

    // If there are no constructors, that means there are no dependencies then
    // we can just resolve the instances of the objects right away, without
    // resolving any other types or dependencies out of these containers.
    if (is_null($constructor)) {
        array_pop($this-&gt;buildStack);

        return new $concrete;
    }

    $dependencies = $constructor-&gt;getParameters();

    // Once we have all the constructor's parameters we can create each of the
    // dependency instances and then use the reflection instances to make a
    // new instance of this class, injecting the created dependencies in.
    $parameters = $this-&gt;keyParametersByArgument(
        $dependencies, $parameters
    );

    $instances = $this-&gt;getDependencies(
        $dependencies, $parameters
    );

    array_pop($this-&gt;buildStack);

    return $reflector-&gt;newInstanceArgs($instances);
}</pre>

<p>具体从容器中获取实例的方法：</p>

<pre class="lang:php decode:true ">protected function resolveClass(ReflectionParameter $parameter)
{
    try {
        return $this-&gt;make($parameter-&gt;getClass()-&gt;name);
    }

    // If we can not resolve the class instance, we will check to see if the value
    // is optional, and if it is we will return the optional parameter value as
    // the value of the dependency, similarly to how we do this with scalars.
    catch (BindingResolutionContractException $e) {
        if ($parameter-&gt;isOptional()) {
            return $parameter-&gt;getDefaultValue();
        }

        throw $e;
    }
}</pre>

<p>框架底层通过Reflection反射为开发节省了很多细节，实现了自动依赖注入。</p>
</div>


    </main>

    
  </body>
</html>
