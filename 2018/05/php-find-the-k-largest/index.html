<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.55.6" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>PHP 查找数组中第 K 大的元素 &middot; 小谈博客</title>

  
  <link type="text/css" rel="stylesheet" href="https://tanteng.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://tanteng.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://tanteng.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://tanteng.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://tanteng.github.io/"><h1>小谈博客</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://tanteng.github.io/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2019. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>PHP 查找数组中第 K 大的元素</h1>
  <time datetime=2018-05-25T08:36:17Z class="post-date">Fri, May 25, 2018</time>
  <p>比如一个数组 [33, 5, 1, 90, 99, 3, 45, 13]，要找出第 K 大的元素，首先可以使用快速排序算法对数组进行排序，然后从排序后的数组中就很容易得到这个元素。</p>

<p>代码如下：</p>

<pre class="lang:php decode:true">&lt;?php

$arr = [33, 5, 1, 90, 99, 3, 45, 13];

// 找到数组中第 K 大的元素
function findK($arr, $k){
    $sortedArr = quickSort($arr);
    echo sprintf("排序结果：%s\n", implode(",", $sortedArr));
    return $sortedArr[count($sortedArr) - $k];
}

// 快速排序
function quickSort($arr){
    if(!isset($arr[0])){
        return $arr;
    }

    if(count($arr) &lt;= 1){
        return $arr;
    }

    $first = $arr[0];
    $left = $right = [];
    foreach ($arr as $item) {
        if($item &lt; $first){
            $left[] = $item;
        }

        if($item &gt; $first){
            $right[] = $item;
        }
    }

    $left = quickSort($left);
    $right = quickSort($right);

    return array_merge($left, array($first), $right);
}

$k = findK($arr, 3);
echo $k . PHP_EOL;
</pre>

<p>虽然可以实现，但是快速排序的时间复杂度最坏是 O(n²)，最好是 O(nlogn)，有没有办法可以优化呢？</p>

<p><img class="aligncenter size-full wp-image-12434" src="https://blog.tanteng.me/wp-content/uploads/2018/05/array-quick-sort.png" alt="" width="632" height="344" /></p>

<p>快速排序算法把元素分成两边分别递归再合并，如图，第一趟会把元素分成左中右三个部分，以第一个元素 33 作为基准，左边是较小的，右边是较大的，右、中、左元素个数是 3，1，4.</p>

<p>那么第 4 大的元素就是中间的 33 了，第 1-3 大的就在右边查找，第 5-8 大的就在左边查找，这样根据 k 可以判断查找的范围，不需要两边都递归排序。</p>

<pre class="lang:php decode:true ">&lt;?php

$arr = [33, 5, 1, 90, 99, 3, 45, 13];

// 找到数组中第 K 大的元素
function findK($arr, $k){
    if(!isset($arr[0])){
        return $arr;
    }

    if(count($arr) &lt;= 1){
        return $arr;
    }

    $first = $arr[0];
    $left = $right = [];
    foreach ($arr as $item) {
        if($item &lt; $first){
            $left[] = $item;
        }

        if($item &gt; $first){
            $right[] = $item;
        }
    }

    $leftnum = count($left);
    $rightnum = count($right);

    if($k == $rightnum + 1){
        return $first;
    }

    if($k &lt; $rightnum + 1){
        $sorted = quickSort($right);
        return $sorted[ $rightnum - $k];
    }

    if($k &gt; $rightnum + 1){
        $sorted = quickSort($left);
        return $sorted[ $k - $leftnum ];
    }
}

//快速排序
function quickSort($arr){
    if(!isset($arr[0])){
        return $arr;
    }

    if(count($arr) &lt;= 1){
        return $arr;
    }

    $first = $arr[0];
    $left = $right = [];
    foreach ($arr as $item) {
        if($item &lt; $first){
            $left[] = $item;
        }

        if($item &gt; $first){
            $right[] = $item;
        }
    }

    $left = quickSort($left);
    $right = quickSort($right);

    return array_merge($left, array($first), $right);
}

$k = findK($arr, 4);
echo $k . PHP_EOL;
</pre>

<p>根据优化思路整理后的算法如上，当然还可以进一步抽象精简，但是这样更保留“思路”，以供参考。</p>
</div>


    </main>

    
  </body>
</html>
