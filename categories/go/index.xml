<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 小谈博客</title>
    <link>http://tanteng.me/categories/go/</link>
    <description>Recent content in Go on 小谈博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 29 May 2018 06:34:04 +0000</lastBuildDate>
    
	<atom:link href="http://tanteng.me/categories/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用 VS Code 断点调试 golang 项目</title>
      <link>http://tanteng.me/2018/05/vscode-debug-golang/</link>
      <pubDate>Tue, 29 May 2018 06:34:04 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/05/vscode-debug-golang/</guid>
      <description>在 golang 开发中进行调试，调试手段除了打印输出、打印日志、单元测试之外，还可以通过 IDE 进行断点调试，这是一个更加直观的方式，这里简单介绍 Visual Studio Code 调试 Golang</description>
    </item>
    
    <item>
      <title>Golang 统计字符串字数</title>
      <link>http://tanteng.me/2018/05/golang-str-length/</link>
      <pubDate>Wed, 02 May 2018 02:52:22 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/05/golang-str-length/</guid>
      <description>&lt;p&gt;比如新浪微博发微博的输入框有一个已输入字数的统计，它的规则推测是：汉字和中文标点算 1 个字数，英文和其他符号算 0.5 个字数。不足 1 个字算 1 个。大家可以去微博体验一下计算方式。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter wp-image-12274 size-full&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2018/05/wx_20180509104614-1.png&#34; alt=&#34;&#34; width=&#34;591&#34; height=&#34;157&#34; /&gt;&lt;/p&gt;

&lt;p&gt;golang 可以使用正则和 unicode 包的方法判断。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mac 上如何打开 /usr/local 路径的文件夹</title>
      <link>http://tanteng.me/2017/11/mac-open-user-local/</link>
      <pubDate>Wed, 29 Nov 2017 14:56:23 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/11/mac-open-user-local/</guid>
      <description>&lt;p&gt;在 Mac 的 Sublime 或者 Visual Studio Code 中选择打开文件夹，无论如何也无法选择 /usr/local 路径，在 Finder 中还可以使用“前往文件夹”输入路径，不过有解决办法，在终端使用命令行的方式启动软件打开指定文件夹，如：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.tanteng.me/wp-content/uploads/2017/11/WX20171129-230540@2x.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img class=&#34;alignnone wp-image-11798 size-full&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2017/11/WX20171129-230540@2x.png&#34; alt=&#34;&#34; width=&#34;600&#34; height=&#34;359&#34; /&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何理解 Golang 的参数传递都是值传递？</title>
      <link>http://tanteng.me/2017/11/golang-parameter-passing/</link>
      <pubDate>Sun, 19 Nov 2017 12:22:01 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/11/golang-parameter-passing/</guid>
      <description>&lt;p&gt;在 Golang 中函数之间传递变量时总是以值的方式传递的，无论是 int,string,bool,array 这样的内置类型（或者说原始的类型），还是 slice,channel,map 这样的引用类型，在函数间传递变量时，都是以值的方式传递，也就是说传递的都是值的副本。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 让 for 循环运行一段时间超时自动退出</title>
      <link>http://tanteng.me/2017/11/golang-for-timeout/</link>
      <pubDate>Sat, 18 Nov 2017 14:48:24 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/11/golang-for-timeout/</guid>
      <description>&lt;p&gt;如何控制 for 循环一段时间超时自动退出呢？思路很简单，就是在 for 循环中使用 select 监听 channel，代码如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:go decode:true&#34;&gt;package main&lt;/p&gt;

&lt;p&gt;import (
    &amp;ldquo;fmt&amp;rdquo;
    &amp;ldquo;time&amp;rdquo;
)&lt;/p&gt;

&lt;p&gt;func main() {
    timeout := time.After(time.Second * 10)
    finish := make(chan bool)
    count := 1
    go func() {
        for {
            select {
            case &amp;lt;-timeout:
                fmt.Println(&amp;ldquo;timeout&amp;rdquo;)
                finish &amp;lt;- true
                return
            default:
                fmt.Printf(&amp;ldquo;haha %d\n&amp;rdquo;, count)
                count++
            }
            time.Sleep(time.Second * 1)
        }
    }()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;lt;-finish

fmt.Println(&amp;quot;Finish&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 如何优雅关闭 channel</title>
      <link>http://tanteng.me/2017/11/golang-close-channel/</link>
      <pubDate>Fri, 17 Nov 2017 09:01:50 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/11/golang-close-channel/</guid>
      <description>&lt;p&gt;Golang 内建的 close 方法可以关闭 channel，如果往已经关闭的 channel 发送数据，则会报错：panic: close of closed channel.&lt;/p&gt;

&lt;p&gt;看如下代码，在一段时间内，生产者可以不断往 channel 写入数据，消费者进行处理，一段时间后 channel 关闭了，这个时候如果还有数据往 channel 发送，程序就会报错。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Golang 发送邮件</title>
      <link>http://tanteng.me/2017/11/golang-smtp-send-mail/</link>
      <pubDate>Thu, 16 Nov 2017 09:45:37 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/11/golang-smtp-send-mail/</guid>
      <description>&lt;p&gt;使用 smtp 协议，只需要邮箱服务器主机和端口，和一个发件人帐号，可以使用 Golang 的 smtp 包发送邮件，以下是一个简单示例：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:go decode:true&#34;&gt;// SendToMail 用于发送邮件
func SendToMail(to, subject, body, mailType string) error {
    user := &amp;ldquo;tt@tanteng.me&amp;rdquo;
    password := 123456
    host := smtp.tanteng.me:25
    hp := strings.Split(host, &amp;ldquo;:&amp;ldquo;)
    auth := smtp.PlainAuth(&amp;ldquo;&amp;rdquo;, user, password, hp[0])
    var contentType string
    if mailType == &amp;ldquo;html&amp;rdquo; {
        contentType = &amp;ldquo;Content-Type: text/&amp;rdquo; + mailType + &amp;ldquo;; charset=UTF-8&amp;rdquo;
    } else {
        contentType = &amp;ldquo;Content-Type: text/plain&amp;rdquo; + &amp;ldquo;; charset=UTF-8&amp;rdquo;
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;msg := []byte(&amp;quot;To: &amp;quot; + to + &amp;quot;\r\nFrom: xx邮箱中心&amp;amp;lt;&amp;quot; + user + &amp;quot;&amp;amp;gt;\r\nSubject: &amp;quot; + subject + &amp;quot;\r\n&amp;quot; + contentType + &amp;quot;\r\n\r\n&amp;quot; + body)
sendTo := strings.Split(to, &amp;quot;;&amp;quot;)
err := smtp.SendMail(host, auth, user, sendTo, msg)
return err
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;重点看 msg 字段，也就是邮件标题，发送者，标题，内容的格式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 中”泛型”的支持</title>
      <link>http://tanteng.me/2017/08/golang-generic/</link>
      <pubDate>Fri, 11 Aug 2017 10:14:10 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/08/golang-generic/</guid>
      <description>&lt;p&gt;Golang不支持一般的类似java中的标记式泛型。很多人因此而十分不满，认为没有泛型增加了很多工作量。而目前由于泛型支持的复杂性，Golang的设计和实现者并没有把这个泛型支持作为紧急需要增加的特性。但是，如果真的没有泛型，就一定不行了么？答案当然是否定的。没有泛型也可以，而且我觉得代码更简单，直接，有趣（个人观点，勿喷）。&lt;/p&gt;

&lt;p&gt;我们这里打算以一些例子来讲解Golang中如何处理这个问题。&lt;/p&gt;

&lt;p&gt;首先，我们看一个冒泡排序的问题。针对整型数组切片的排序。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 解析 json 数据</title>
      <link>http://tanteng.me/2017/07/golang-decode-json/</link>
      <pubDate>Sun, 23 Jul 2017 14:04:44 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/07/golang-decode-json/</guid>
      <description>&lt;p&gt;使用 Golang 解析 json 数据，这种 json 格式是对象的数组，官方文档有一个示例：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:go decode:true&#34;&gt;var jsonBlob = []byte(&lt;code&gt;[  
    {&amp;quot;Name&amp;quot;: &amp;quot;Platypus&amp;quot;, &amp;quot;Order&amp;quot;: &amp;quot;Monotremata&amp;quot;},  
    {&amp;quot;Name&amp;quot;: &amp;quot;Quoll&amp;quot;,    &amp;quot;Order&amp;quot;: &amp;quot;Dasyuromorphia&amp;quot;}  
]&lt;/code&gt;)&lt;br /&gt;
type Animal struct {&lt;br /&gt;
    Name  string&lt;br /&gt;
    Order string&lt;br /&gt;
}&lt;br /&gt;
var animals []Animal&lt;br /&gt;
err := json.Unmarshal(jsonBlob, &amp;amp;animals)&lt;br /&gt;
if err != nil {&lt;br /&gt;
    fmt.Println(&amp;ldquo;error:&amp;ldquo;, err)&lt;br /&gt;
}&lt;br /&gt;
fmt.Printf(&amp;ldquo;%+v&amp;rdquo;, animals)&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 模拟生产者消费者</title>
      <link>http://tanteng.me/2017/07/go-producer-consumer/</link>
      <pubDate>Sat, 08 Jul 2017 10:44:36 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/07/go-producer-consumer/</guid>
      <description>&lt;p&gt;Go 的一个模拟生产者和消费者的例子，用 m 个 goroutine 生产产品，用 n 个 goroutine 消费产品，使用 2 个 channel，一个有缓冲的通道用于存放产品，一个无缓冲的通道用于标识生成或者消费过程完成。&lt;/p&gt;

&lt;p&gt;例子演示了 Go 中 goroutine 和 channel 的使用，理解 Go 中的并发概念。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>defer使用规则</title>
      <link>http://tanteng.me/2017/07/defer-golang/</link>
      <pubDate>Thu, 06 Jul 2017 08:17:34 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/07/defer-golang/</guid>
      <description>&lt;p&gt;在golang当中，defer代码块会在函数调用链表中增加一个函数调用。这个函数调用不是普通的函数调用，而是会在函数正常返回，也就是return之后添加一个函数调用。因此，defer通常用来释放函数内部变量。&lt;/p&gt;

&lt;p&gt;为了更好的学习defer的行为，我们首先来看下面一段代码:&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:go decode:true &#34;&gt;func CopyFile(dstName, srcName string) (written int64, err error) {
    src, err := os.Open(srcName)
    if err != nil {
        return
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dst, err := os.Create(dstName)
if err != nil {
    return
}

written, err = io.Copy(dst, src)
dst.Close()
src.Close()
return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 遍历一个月写法</title>
      <link>http://tanteng.me/2017/06/golang-month-iteration/</link>
      <pubDate>Tue, 20 Jun 2017 06:41:58 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/06/golang-month-iteration/</guid>
      <description>Golang 遍历一个月每天写法： // CreateOnlineTable 创建统计用户在线时长表 func CreateOnlineTable() { year, month, _ := time.Now().Date() t := time.Date(year, month+1, 0, 0, 0, 0, 0, time.UTC) for day := 1; day &amp;lt;= t.Day(); day++ { date := time.Now().Format(&amp;ldquo;200601&amp;rdquo;) + fmt.Sprintf(&amp;ldquo;%02d&amp;rdquo;, day) tableName := fmt.Sprintf(utils.LoadIniConfig(&amp;ldquo;online&amp;rdquo;, &amp;ldquo;online&amp;rdquo;, &amp;ldquo;db&amp;rdquo;), date) template := utils.LoadIniConfig(&amp;ldquo;online&amp;rdquo;, &amp;ldquo;online_template&amp;rdquo;, &amp;ldquo;db&amp;rdquo;) sql :=</description>
    </item>
    
    <item>
      <title>使用 goroutine 并发写 map 问题</title>
      <link>http://tanteng.me/2017/06/goroutine-concurrent-map-writes/</link>
      <pubDate>Mon, 19 Jun 2017 10:41:21 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/06/goroutine-concurrent-map-writes/</guid>
      <description>&lt;p&gt;使用 goroutine 并发写 map 是一个非线程安全的方式，要避免对一个全局变量在 goroutine 中进行写操作，这会导致并发写问题。&lt;/p&gt;

&lt;p&gt;以下例子可以触发此类错误：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:go decode:true&#34;&gt;package main&lt;/p&gt;

&lt;p&gt;var testMap = make(map[string]string)&lt;/p&gt;

&lt;p&gt;func main() {
    for i := 0; i &amp;lt; 33; i++ {
        go func() {
            testMap[&amp;ldquo;aa&amp;rdquo;] = &amp;ldquo;bb&amp;rdquo;
        }()
    }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于 const 常量和只读全局变量，是线程安全的，但不能并发写。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在 Golang 定时任务中判断函数是否执行完成</title>
      <link>http://tanteng.me/2017/06/golang-function-done/</link>
      <pubDate>Mon, 19 Jun 2017 10:02:34 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/06/golang-function-done/</guid>
      <description>&lt;p&gt;使用 golang 的定时任务（采用 robfig/cron 包），每 5s 调用一个函数进行处理，但是这个函数的处理可能会耗时，在没有执行完之前如果再次调用，就会导致计算结果不对。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang中的面向对象继承</title>
      <link>http://tanteng.me/2017/06/golang-oop-extends/</link>
      <pubDate>Sat, 03 Jun 2017 08:19:03 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/06/golang-oop-extends/</guid>
      <description>&lt;p&gt;Golang的面向对象机制与Smalltalk或者Java等传统面向对象的编程语言不同。传统面向对象编程语言的一个重要特性是继承机制。因为继承机制支持在关联对象间进行代码复用和数据共享。继承机制曾在代码复用和数据共享的设计模式占据主导地位，但是目前组合这一古老的技术重新焕发了活力。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Trie 树结构介绍</title>
      <link>http://tanteng.me/2017/05/trie-intro/</link>
      <pubDate>Fri, 26 May 2017 03:17:14 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/05/trie-intro/</guid>
      <description>使用一个 Golang 的敏感词过滤服务（https://github.com/huayuego/wordfilter），这个服务用到了 Trie 树存储词典。 这篇</description>
    </item>
    
    <item>
      <title>Golang slice 和 PHP 数组比较</title>
      <link>http://tanteng.me/2017/05/golang-php-array-slice-compare/</link>
      <pubDate>Sat, 20 May 2017 06:48:59 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/05/golang-php-array-slice-compare/</guid>
      <description>&lt;div class=&#34;card-title&#34;&gt;
  &lt;h2&gt;
    Creating
  &lt;/h2&gt;
&lt;/div&gt;

&lt;p&gt;Create an array in PHP&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:default decode:true&#34;&gt;$myStringArray = [&amp;ldquo;One&amp;rdquo;,&amp;ldquo;Two&amp;rdquo;,&amp;ldquo;Three&amp;rdquo;];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In Go creating the above is a little more verbose and like variable assignment above there&amp;#8217;s also multiple ways to create a slice. The most similar way to that of PHP is as follows.&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:default decode:true&#34;&gt;myStringArray := []string{&amp;ldquo;One&amp;rdquo;,&amp;ldquo;Two&amp;rdquo;,&amp;ldquo;Three&amp;rdquo;}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 字节切片初始化</title>
      <link>http://tanteng.me/2017/05/golang-byte-slice/</link>
      <pubDate>Sat, 20 May 2017 05:42:54 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/05/golang-byte-slice/</guid>
      <description>golang 中注意下面两种字节切片类型的初始化，一个是括号，一个是花括号，其中括号会对字符串内容进行类型转换。 func main() { test := []byte(&amp;ldquo;a</description>
    </item>
    
    <item>
      <title>Golang append slice to slice</title>
      <link>http://tanteng.me/2017/05/golang-append-slice-to-slice/</link>
      <pubDate>Wed, 10 May 2017 07:11:22 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/05/golang-append-slice-to-slice/</guid>
      <description>&lt;p&gt;把一个 slice 追加到另一个 slice，以下两种方式都是把 s1 追加到 s0 中，但两种结果不同，注意区别。&lt;/p&gt;

&lt;p&gt;片段1：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:go decode:true&#34;&gt;s0 := []interface{}{1, 100, 122}
s1 := []interface{}{3, 4, 5, 6}
s0 = append(s0, s1)
fmt.Println(&amp;ldquo;result:&amp;ldquo;, s0) //result: [1 100 122 [3 4 5 6]]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此时 s0 结果：result: [1 100 122 [3 4 5 6]]&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 生成整数随机数</title>
      <link>http://tanteng.me/2017/04/golang-rand-int/</link>
      <pubDate>Sat, 22 Apr 2017 04:37:12 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/04/golang-rand-int/</guid>
      <description>&lt;p&gt;生成一个给定范围的随机数，用 PHP 就太简单不过了，而且可以指定从负数到正整数的范围，如：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;?php
echo mt_rand(-988, 888);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样就随机生成 -988 到 888 的随机数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 搭建 WebSocket 服务端例子</title>
      <link>http://tanteng.me/2017/02/go-websocket-demo/</link>
      <pubDate>Mon, 27 Feb 2017 03:13:54 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/02/go-websocket-demo/</guid>
      <description>&lt;p&gt;WebSocket 是一个基于 HTML5 规范的，可以实现客户端和服务器双向通信的协议，弥补了 HTTP 协议只能客户端主动发请求，服务器响应，而服务器不能给客户端推送数据的不足。&lt;/p&gt;

&lt;h3 id=&#34;websocket-握手&#34;&gt;WebSocket 握手&lt;/h3&gt;

&lt;p&gt;&lt;code class=&#34;lang:default decode:true&#34;&gt;GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: &lt;a href=&#34;http://example.com&#34;&gt;http://example.com&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;重点如下两个 header：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:default decode:true&#34;&gt;Upgrade: websocket
Connection: Upgrade&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Upgrade 表示升级到 WebSocket 协议，Connection 表示这个 HTTP 请求是一次协议升级，Origin 表示发请求的来源。&lt;/p&gt;

&lt;h3 id=&#34;websocket-api&#34;&gt;WebSocket API&lt;/h3&gt;

&lt;p&gt;① 打开新的 WebSocket 连接&lt;/p&gt;

&lt;p&gt;② 可选的回调，在连接出错时调用&lt;/p&gt;

&lt;p&gt;③ 可选的回调，在连接终止时调用&lt;/p&gt;

&lt;p&gt;④ 可选的回调，在 WebSocket 连接建立时调用&lt;/p&gt;

&lt;p&gt;⑤ 客户端向服务器发送消息&lt;/p&gt;

&lt;p&gt;⑥ 回调函数，接收服务器主动发送的消息&lt;/p&gt;

&lt;p&gt;⑦ 根据接收到的消息，决定调用二进制还是文本处理逻辑&lt;/p&gt;

&lt;p&gt;下面 js 示例包括了上面大部分的 API.&lt;/p&gt;

&lt;h3 id=&#34;go-搭建-websocket-服务端的例子&#34;&gt;Go 搭建 WebSocket 服务端的例子&lt;/h3&gt;

&lt;p&gt;Go 搭建一个简单 WebSocket 服务端代码例子 test.go, 如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:go decode:true &#34;&gt;package main&lt;/p&gt;

&lt;p&gt;import (
    &amp;ldquo;fmt&amp;rdquo;
    &amp;ldquo;log&amp;rdquo;
    &amp;ldquo;net/http&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;golang.org/x/net/websocket&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;)&lt;/p&gt;

&lt;p&gt;func Echo(ws *websocket.Conn) {
    var err error&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for {
    var reply string

    if err = websocket.Message.Receive(ws, &amp;amp;reply); err != nil {
        fmt.Println(&amp;quot;Can&#39;t receive&amp;quot;)
        break
    }

    fmt.Println(&amp;quot;Received back from client: &amp;quot; + reply)

    msg := &amp;quot;Received:  &amp;quot; + reply
    fmt.Println(&amp;quot;Sending to client: &amp;quot; + msg)

    if err = websocket.Message.Send(ws, msg); err != nil {
        fmt.Println(&amp;quot;Can&#39;t send&amp;quot;)
        break
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;func main() {
    http.Handle(&amp;ldquo;/&amp;rdquo;, websocket.Handler(Echo))&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if err := http.ListenAndServe(&amp;quot;:1234&amp;quot;, nil); err != nil {
    log.Fatal(&amp;quot;ListenAndServe:&amp;quot;, err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>