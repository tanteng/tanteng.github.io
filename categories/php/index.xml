<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PHP on 小谈博客</title>
    <link>http://tanteng.me/categories/php/</link>
    <description>Recent content in PHP on 小谈博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 15 Sep 2018 05:41:51 +0000</lastBuildDate>
    
	<atom:link href="http://tanteng.me/categories/php/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Laravel 错误和异常处理用法</title>
      <link>http://tanteng.me/2018/09/laravel-error-handing/</link>
      <pubDate>Sat, 15 Sep 2018 05:41:51 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/09/laravel-error-handing/</guid>
      <description>&lt;p&gt;Laravel 自带错误和异常处理，App\Exceptions\Handler 负责上报异常和如何返回内容，以及未登录的处理。App\Exceptions\Handler 位于 app\Exceptions\Handler.php，下面介绍这个类的属性和用法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 用户授权系统使用小结</title>
      <link>http://tanteng.me/2018/09/laravel-authorize-gates/</link>
      <pubDate>Fri, 14 Sep 2018 11:04:59 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/09/laravel-authorize-gates/</guid>
      <description>&lt;h3 id=&#34;-1&#34;&gt;基本用法&lt;/h3&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$this-&amp;gt;authorize(&amp;lsquo;update&amp;rsquo;, $post);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;第一个参数 $ability,表示具备什么权限。第二个参数 $post，是一个模型实例。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel chunk 使用注意的问题</title>
      <link>http://tanteng.me/2018/08/laravel-chunk-tip/</link>
      <pubDate>Tue, 14 Aug 2018 15:39:12 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/08/laravel-chunk-tip/</guid>
      <description>&lt;p&gt;使用 Laravel 的 chunk 可以用来优化大结果集的查询，提供分块处理数据的方法，但是如下的例子就会有问题：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:default decode:true &#34;&gt;User::where(&amp;lsquo;approved&amp;rsquo;, 0)-&amp;gt;chunk(100, function ($users) {
  foreach ($users as $user) {
    $user-&amp;gt;update([&amp;lsquo;approved&amp;rsquo; =&amp;gt; 1]);
  }
});&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;原因在于第一次查询：&lt;/p&gt;

&lt;p&gt;select * from users where approved = 0 limit 100 offset 0;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 中为何不使用 blpop 取队列？</title>
      <link>http://tanteng.me/2018/08/laravel-why-not-use-blpop/</link>
      <pubDate>Tue, 31 Jul 2018 17:18:21 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/08/laravel-why-not-use-blpop/</guid>
      <description>&lt;p&gt;Redis 的 list 数据结构常用来做消息队列，通常使用的命令有 lpop/rpop ，还有带阻塞版的 blpop/brpop 等。blpop 的优点是避免一直轮询占用资源，而且支持多个列表作为参数并按照顺序弹出数据，如 blpop high low 30，可以更方便实现队列的优先级。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 中间件原理</title>
      <link>http://tanteng.me/2018/07/understand-laravel-middleware/</link>
      <pubDate>Sun, 29 Jul 2018 16:25:08 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/07/understand-laravel-middleware/</guid>
      <description>&lt;p&gt;Laravel 的中间件机制提供了一种管道的方式，每个 HTTP 请求经过一个又一个中间件进行过滤，Laravel 内置了很多中间件，比如 CSRF 机制，身份认证，Cookie 加密，设置 Cookie 等等。&lt;/p&gt;

&lt;p&gt;本文就来探究 Laravel 中间件的实现原理，看 Laravel 如何把 PHP 的 array_reduce 函数和闭包用到了极致。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 事件系统用法总结</title>
      <link>http://tanteng.me/2018/06/laravel-event/</link>
      <pubDate>Sun, 17 Jun 2018 02:10:52 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/06/laravel-event/</guid>
      <description>&lt;p&gt;Laravel 的事件提供了一个简单的观察者实现，能够订阅和监听应用中发生的各种事件。事件类保存在 app/Events 目录中，而这些事件的的监听器则被保存在 app/Listeners 目录下。这些目录只有当你使用 Artisan 命令来生成事件和监听器时才会被自动创建。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在 Laravel 中使用 gulp 构建前端资源</title>
      <link>http://tanteng.me/2018/05/laravel-5-5-gulp/</link>
      <pubDate>Mon, 28 May 2018 12:45:32 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/05/laravel-5-5-gulp/</guid>
      <description>&lt;p&gt;最近把自己主页前端代码进一步规范了，使用 npm 引入一些前端的资源库，在 Laravel 5.5 中使用 gulp 遇到一些坑。&lt;/p&gt;

&lt;p&gt;mix.sass 无法直接使用 node_modules 文件夹里的，只能用 resource/assets/sass/app.scss 这个文件生成 css，然后和其他的 css 合并为一个文件。&lt;/p&gt;

&lt;p&gt;mix.scripts 可以使用 node_modules 文件夹里的 js，并和自己的 js 合并为一个文件。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在旧有 PHP 系统上集成七牛云 PHP-SDK</title>
      <link>http://tanteng.me/2018/05/php-qiniu-sdk-not-support-composer/</link>
      <pubDate>Mon, 28 May 2018 11:32:34 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/05/php-qiniu-sdk-not-support-composer/</guid>
      <description>&lt;p&gt;最近在一个古老的 PHP 系统上使用七牛云的上传图片功能，需要集成七牛云提供的 PHP-SDK，这个系统暂时不支持 composer，还好七牛云这个 SDK 不依赖其他的包，于是事情就变得简单了，只需要提供一个 sql_autoload_register 方法注册自动加载机制就可以使用了。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;&amp;lt;?php&lt;/p&gt;

&lt;p&gt;use Qiniu\Auth;
use Qiniu\Storage\UploadManager;&lt;/p&gt;

&lt;p&gt;//本框架不支持 composer，为了用七牛云，又不敢在全局用 sql_autoload_register，目前就在当前活动引入七牛云的 SDK
spl_autoload_register(&amp;lsquo;classLoader&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;function classLoader($class)
{
    $path = str_replace(&amp;rsquo;\&amp;rsquo;, DIRECTORY_SEPARATOR, $class);
    $file = SDK_PATH . &amp;lsquo;vendor/&amp;rsquo; . $path . &amp;lsquo;.php&amp;rsquo;;
    if (file_exists($file)) {
        require_once $file;
    }
}&lt;/p&gt;

&lt;p&gt;require_once SDK_PATH . &amp;lsquo;vendor/Qiniu/functions.php&amp;rsquo;;&lt;/p&gt;

&lt;p&gt;class xxxx extends baseIndex{&lt;/p&gt;

&lt;p&gt;//&lt;/p&gt;

&lt;p&gt;}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP 查找数组中第 K 大的元素</title>
      <link>http://tanteng.me/2018/05/php-find-the-k-largest/</link>
      <pubDate>Fri, 25 May 2018 08:36:17 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/05/php-find-the-k-largest/</guid>
      <description>&lt;p&gt;比如一个数组 [33, 5, 1, 90, 99, 3, 45, 13]，要找出第 K 大的元素，首先可以使用快速排序算法对数组进行排序，然后从排序后的数组中就很容易得到这个元素。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 模型间关系设置分表方法</title>
      <link>http://tanteng.me/2018/04/laravel-relationships-settable/</link>
      <pubDate>Thu, 19 Apr 2018 11:49:32 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/04/laravel-relationships-settable/</guid>
      <description>&lt;p&gt;在实际开发中经常用到分库分表，比如用户表分成 100 张，那么这个时候查询数据需要设置分表，比如 Laravel 的 Model 类中提供了 setTable 方法：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/**
 * Set the table associated with the model.
 *
 * @param  string  $table
 * @return $this
 */
public function setTable($table)
{
    $this-&amp;gt;table = $table;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return $this;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP知识整理之——PHP基础、WEB安全、网络</title>
      <link>http://tanteng.me/2018/04/php-interview-2/</link>
      <pubDate>Tue, 10 Apr 2018 03:11:14 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/04/php-interview-2/</guid>
      <description>&lt;p&gt;本篇文章是PHP知识系统整理系列之——PHP基础、WEB安全、网络，包括 PSR 规范，PHP7特性和性能提升，HTTP、HTTPS、TCP、WebSocket协议，WEB安全和计算机网络的内容。以及 PHP session 回收，php-fpm 调优，HTTP/2 等知识点。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Docker 搭建开发环境</title>
      <link>http://tanteng.me/2018/03/docker-dev-environment/</link>
      <pubDate>Thu, 29 Mar 2018 02:48:04 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/03/docker-dev-environment/</guid>
      <description>&lt;p&gt;做了一次分享，主题《使用 Docker 搭建开发环境》，简单介绍了一下 Docker 的概念，演示了使用 Docker-compose 构建全套 PHP 环境。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.tanteng.me/wp-content/uploads/2018/03/62669ad9gy1fprunalxubj219c0xqaev.jpg&#34; target=&#34;_blank&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-11994&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2018/03/62669ad9gy1fprunalxubj219c0xqaev.jpg&#34; alt=&#34;&#34; width=&#34;1024&#34; height=&#34;762&#34; /&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP写时复制（Copy On Write）</title>
      <link>http://tanteng.me/2018/03/php-cow/</link>
      <pubDate>Mon, 26 Mar 2018 14:04:07 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/03/php-cow/</guid>
      <description>&lt;p&gt;一个例子：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;?php
$foo = 1;
$bar = $foo;
echo $foo + $bar;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;变量 $foo 赋值给变量 $bar，这两个变量具有相同的值，没有必要新申请内存空间，他们可以共享同一块内存。在很多场景下PHP 的 COW 对内存进行优化。比如：变量的多次赋值、函数参数传递，并在函数体内修改实参等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 依赖注入源码解析</title>
      <link>http://tanteng.me/2018/01/laravel-dependency/</link>
      <pubDate>Thu, 18 Jan 2018 09:25:57 +0000</pubDate>
      
      <guid>http://tanteng.me/2018/01/laravel-dependency/</guid>
      <description>&lt;p&gt;在 Laravel 的控制器的构造方法或者成员方法，都可以通过类型约束的方式使用依赖注入，如：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public function store(Request $request)
{
    //TODO
}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里 $request 参数就使用了&lt;a href=&#34;http://php.net/manual/zh/language.oop5.typehinting.php&#34; target=&#34;_blank&#34; rel=&#34;noopener nofollow&#34;&gt;&lt;strong&gt;类型约束&lt;/strong&gt;&lt;/a&gt;，Request 是一个类:\Illuminate\Http\Request，表示参数必须是这个类或子类。&lt;/p&gt;

&lt;p&gt;本文通过分析 Laravel 的源码，看为什么方法中不需要传入实例就可以直接使用 Request 呢？只是框架自动帮我们实例化并传参了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>为什么 Laravel 会重复执行同一个队列任务？</title>
      <link>http://tanteng.me/2017/12/laravel-queue-excute/</link>
      <pubDate>Sun, 24 Dec 2017 07:49:30 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/12/laravel-queue-excute/</guid>
      <description>&lt;p&gt;在 Laravel 中使用 Redis 处理队列任务，框架提供的功能非常强大，但是最近遇到一个问题，就是发现一个任务被多次执行，这是为什么呢？&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter wp-image-11887&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2017/12/laravel.jpg&#34; alt=&#34;&#34; width=&#34;380&#34; height=&#34;260&#34; /&gt;&lt;/p&gt;

&lt;p&gt;先说原因：因为在 Laravel 中如果一个队列（任务）执行时间大于 60 秒，就会被认为执行失败并重新加入队列中，这样就会导致重复执行同一个任务。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel Redis 多个进程同时取队列问题</title>
      <link>http://tanteng.me/2017/12/laravel-supervisor-queue/</link>
      <pubDate>Sat, 23 Dec 2017 11:26:19 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/12/laravel-supervisor-queue/</guid>
      <description>&lt;p&gt;&lt;strong&gt;开启多个进程处理队列会重复读取 Redis 中队列吗？是否因此导致重复执行任务？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用 Supervisor 监听 Laravel 队列任务，其中 Supervisor 的配置如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:default decode:true&#34;&gt;[program:laravel-worker]
process_name=%(program&lt;em&gt;name)s&lt;/em&gt;%(process_num)02d
command=php /var/www/xxx.cn/artisan queue:work &amp;ndash;queue=sendfile &amp;ndash;tries=3 &amp;ndash;daemon
autostart=true
autorestart=true
numprocs=8
redirect_stderr=true
stdout_logfile=/var/www/xxx.cn/worker.log
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意 numprocs = 8，代表开启 8 个进程来执行 command 中的命令。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Laravel 消息队列要注意的问题</title>
      <link>http://tanteng.me/2017/12/laravel-queue-tips/</link>
      <pubDate>Mon, 11 Dec 2017 10:08:13 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/12/laravel-queue-tips/</guid>
      <description>&lt;p&gt;使用 Laravel 的消息队列处理异步任务，Redis 作为队列数据库，Supervisor 监控脚本异常中断并自动重启，这是 Laravel 处理队列任务的标准流程，但是实际中可能还会出现各种各样的问题，为了保证系统&lt;strong&gt;可靠性&lt;/strong&gt;，还要注意几个问题。&lt;/p&gt;

&lt;h3 id=&#34;一-执行失败重试次数设置&#34;&gt;一、执行失败重试次数设置&lt;/h3&gt;

&lt;p&gt;一定要设置任务执行失败重试次数，避免无限失败重试，超过重试次数 Laravel 会默认写到失败任务表中，也可以自己写执行失败后续处理逻辑。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php artisan queue:work redis &amp;ndash;tries=3&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP 中“流”的概念</title>
      <link>http://tanteng.me/2017/12/php-stream/</link>
      <pubDate>Thu, 07 Dec 2017 15:03:29 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/12/php-stream/</guid>
      <description>链接：http://www.cunmou.com/phpbook/14.md</description>
    </item>
    
    <item>
      <title>php.ini 几个配置项说明</title>
      <link>http://tanteng.me/2017/12/php-ini-config/</link>
      <pubDate>Mon, 04 Dec 2017 03:56:10 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/12/php-ini-config/</guid>
      <description>&lt;p&gt;php.ini 几个常用的配置项整理。&lt;/p&gt;

&lt;h3 id=&#34;max-execution-time&#34;&gt;max_execution_time&lt;/h3&gt;

&lt;p&gt;&lt;code class=&#34;lang:default decode:true&#34;&gt;; Maximum execution time of each script, in seconds
; &lt;a href=&#34;http://php.net/max-execution-time&#34;&gt;http://php.net/max-execution-time&lt;/a&gt;
; Note: This directive is hardcoded to 0 for the CLI SAPI
max_execution_time = 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这设置了脚本被解析器中止之前允许的最大执行时间，单位秒。 这有助于防止写得不好的脚本占尽服务器资源。 默认设置为 30。 从命令行运行 PHP 时，默认设置为 0。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 中的简单工厂和抽象工厂</title>
      <link>http://tanteng.me/2017/11/laravel-factory-pattern/</link>
      <pubDate>Wed, 22 Nov 2017 03:35:54 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/11/laravel-factory-pattern/</guid>
      <description>&lt;p&gt;设计模式之工厂模式分为三种：简单工厂、工厂方法和抽象工厂模式，有时也把简单工厂和工厂方法这两种归为一类。工厂模式属于“创建”型的设计模式，顾名思义用来实例化对象，调用者不需要关心对象的具体创建过程，以达到解耦的目的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP-FPM,Nginx,FastCGI 之间的关系</title>
      <link>http://tanteng.me/2017/11/nginx-fastcgi-php-fpm/</link>
      <pubDate>Thu, 09 Nov 2017 08:44:27 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/11/nginx-fastcgi-php-fpm/</guid>
      <description>&lt;p&gt;本文介绍 PHP-FPM,Nginx,FastCGI 三者之间的关系，以及 Nginx 反向代理和负载均衡的配置。&lt;/p&gt;

&lt;h3 id=&#34;php-fpm-nginx-fastcgi-之间的关系&#34;&gt;PHP-FPM,Nginx,FastCGI 之间的关系&lt;/h3&gt;

&lt;p&gt;FastCGI 是一个协议，它是应用程序和 WEB 服务器连接的桥梁。Nginx 并不能直接与 PHP-FPM 通信，而是将请求通过 FastCGI 交给 PHP-FPM 处理。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:default decode:true&#34;&gt;location ~ .php$ {
    try_files $uri /index.php =404;
    fastcgi_pass 127.0.0.1:9000;
    fastcgi_index index.php;
    fastcgi_buffers 16 16k;
    fastcgi_buffer_size 32k;
    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    include fastcgi_params;
}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 服务提供者和门面模式</title>
      <link>http://tanteng.me/2017/11/laravel-facade-service-provider/</link>
      <pubDate>Sun, 05 Nov 2017 16:30:33 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/11/laravel-facade-service-provider/</guid>
      <description>&lt;p&gt;以 Laravel 自带的文件系统为例，在 config/app.php 的配置文件的 providers 数组中，注册了一个服务提供者：&lt;/p&gt;

&lt;p class=&#34;lang:php decode:true  &#34;&gt;
  Illuminate\Filesystem\FilesystemServiceProvider::class,
&lt;/p&gt;

&lt;p&gt;在 alias 数组中定义了一个门面：&lt;/p&gt;

&lt;p class=&#34;lang:php decode:true  &#34;&gt;
  &amp;#8216;File&amp;#8217; =&gt; Illuminate\Support\Facades\File::class,
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP intval 转换浮点数精度丢失问题</title>
      <link>http://tanteng.me/2017/10/php-intval-precision/</link>
      <pubDate>Sun, 15 Oct 2017 08:15:42 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/10/php-intval-precision/</guid>
      <description>&lt;p&gt;在 PHP 和其他一些语言都会存在这个问题，转换浮点数为整数的时候会出现精度丢失，如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;&amp;lt;?php
$n=&amp;ldquo;19.99&amp;rdquo;;
print intval($n*100); // prints 1998&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;解决办法&#34;&gt;解决办法：&lt;/h3&gt;

&lt;p&gt;1.转换成字符串再 intval&lt;/p&gt;

&lt;p&gt;&lt;code&gt;print intval(strval($n*100)); // prints 1999&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.使用 round 函数替代 floatval&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;php -r &amp;ldquo;echo round(19.99*100);&amp;rdquo;&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Docker 搭建 Laravel 本地环境</title>
      <link>http://tanteng.me/2017/10/docker-laravel-local-environment/</link>
      <pubDate>Sat, 14 Oct 2017 11:28:48 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/10/docker-laravel-local-environment/</guid>
      <description>&lt;p&gt;Laravel 官方提供 Homestead 和 Valet 作为本地开发环境，Homestead 是一个官方预封装的 Vagrant Box，也就是一个虚拟机，但是跟 docker 比，它占用体积太大，启动速度慢，同时响应速度很慢，现在有了 docker 这种更好的方式，可以轻松方便的搭建整套 PHP 开发环境。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laradock 使用 ssh 方式连接 workspace</title>
      <link>http://tanteng.me/2017/09/laradock-ssh-workspace/</link>
      <pubDate>Thu, 21 Sep 2017 06:39:26 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/09/laradock-ssh-workspace/</guid>
      <description>&lt;p&gt;最近在学习 Docker，发现 Laradock 这个项目，它是以 docker-compose 方式快速搭建一整套 PHP 开发环境的镜像，可以按需启动需要的容器，包括 MySQL，Redis，Nginx，Memcache，RabbitMQ，Mongo 等一系列 WEB 开发需要的软件。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>WordPress 使用 Redis 缓存</title>
      <link>http://tanteng.me/2017/09/wp-redis/</link>
      <pubDate>Wed, 13 Sep 2017 04:32:13 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/09/wp-redis/</guid>
      <description>&lt;p&gt;给 WordPress 博客换了一个缓存插件 —— WP Redis，使用 Redis 缓存给博客提高速度和性能，之前用的插件 WP Super Cache 是基于文件缓存的，虽然也很不错，但是用 Redis 应该是更好的选择。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP 调试函数 debug_backtrace</title>
      <link>http://tanteng.me/2017/09/debug-backtrace-php/</link>
      <pubDate>Mon, 11 Sep 2017 07:37:49 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/09/debug-backtrace-php/</guid>
      <description>&lt;p&gt;有时候我们想知道这个函数或方法的调用堆栈，也就是它是如何一级一级是被调用到的，可以用 PHP 的 debug_backtrace 函数打印，就像这样：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;public function update(Request $request, $id)
{
    dd(debug_backtrace());
    $getGameID = function ($request) {
        if (!$request-&amp;gt;game_id) {
            return 1000 + intval($request-&amp;gt;id);
        }
        return $request-&amp;gt;game_id;
    };&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$previews = $this-&amp;amp;gt;getGamePreviews($request-&amp;amp;gt;game_preview);

$request-&amp;amp;gt;merge([
    &#39;game_preview&#39; =&amp;amp;gt; json_encode($previews),
    &#39;game_id&#39;      =&amp;amp;gt; $getGameID($request)
]);
EgretGame::where(&#39;id&#39;, $id)-&amp;amp;gt;update($request-&amp;amp;gt;except([&#39;_token&#39;, &#39;_method&#39;]));
return redirect()-&amp;amp;gt;route(&#39;egretgame.index&#39;)-&amp;amp;gt;with(&#39;success&#39;, &#39;编辑成功！&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel Sessionid 处理机制</title>
      <link>http://tanteng.me/2017/09/laravel-session-scheme/</link>
      <pubDate>Mon, 11 Sep 2017 03:41:20 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/09/laravel-session-scheme/</guid>
      <description>&lt;p&gt;在 Laravel 的配置文件 config/session.php 中可以设置 Session Cookie Name，比如这个项目中设置名称为“sns_session”：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;/*
|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
| Session Cookie Name
|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;
|
| Here you may change the name of the cookie used to identify a session
| instance by ID. The name specified here will get used every time a
| new session cookie is created by the framework for every driver.
|
*/&lt;/p&gt;

&lt;p&gt;&amp;lsquo;cookie&amp;rsquo; =&amp;gt; &amp;lsquo;sns_session&amp;rsquo;,&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到刷新页面，查看 cookie，会发现一个名称为 sns_session 的 cookie，名字就是我们自定义的。&lt;/p&gt;

&lt;p&gt;这个 sessionid 就是 cookie 和 session 联系的桥梁，服务器通过这个 sessionid 判断来自哪个客户端的请求。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP 错误和异常处理</title>
      <link>http://tanteng.me/2017/09/php-error-handle/</link>
      <pubDate>Sat, 02 Sep 2017 07:27:24 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/09/php-error-handle/</guid>
      <description>&lt;p&gt;关于 PHP 的错误和异常处理，总结如下。&lt;/p&gt;

&lt;h3 id=&#34;1-设置-php-错误级别&#34;&gt;1.设置 PHP 错误级别&lt;/h3&gt;

&lt;p&gt;使用 &lt;span class=&#34;refname&#34;&gt;error_reporting&lt;/span&gt; — &lt;span class=&#34;dc-title&#34;&gt;设置应该报告何种 PHP 错误。&lt;/span&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP发送HTTP请求的几种方式</title>
      <link>http://tanteng.me/2017/07/php-curl-guzzlehttp/</link>
      <pubDate>Sat, 22 Jul 2017 06:02:45 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/07/php-curl-guzzlehttp/</guid>
      <description>&lt;p&gt;PHP 开发中我们常用 cURL 方式封装 HTTP 请求，什么是 cURL？&lt;/p&gt;

&lt;p&gt;cURL 是一个用来传输数据的工具，支持多种协议，如在 Linux 下用 curl 命令行可以发送各种 HTTP 请求。PHP 的 cURL 是一个底层的库，它能根据不同协议跟各种服务器通讯，HTTP 协议是其中一种。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP笔试面试题精选（一）</title>
      <link>http://tanteng.me/2017/07/php-examination-part-1/</link>
      <pubDate>Tue, 11 Jul 2017 02:02:05 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/07/php-examination-part-1/</guid>
      <description>&lt;p&gt;本次课程主要围绕 PHP 面试和笔试中经常会出现的一些知识点，&lt;strong&gt;但是面试官会在笔试题基础上深入扩展，那么你知道如何更好的回答让面试官满意吗？&lt;/strong&gt;题目收集自腾讯，迅雷，美图等公司的笔试面试题，以及本人面试经历中印象中的知识点，同时也分享一些面试的经验，相信对你一定有很大的参考价值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>WEB API接口安全和防刷</title>
      <link>http://tanteng.me/2017/06/web-api-security/</link>
      <pubDate>Fri, 16 Jun 2017 13:07:48 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/06/web-api-security/</guid>
      <description>&lt;p&gt;做各种活动经常会涉及到送会员、礼券、奖品、抽奖、刷榜等业务，这些活动都有一个共同点，那就是恶意用户找到漏洞请求接口从而获取利益，所以要做好这些WEB接口的安全，这里总结一下实践中对这些WEB接口做的安全措施和防刷机制。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于 cgi, fastcgi, php-fpm 的关系</title>
      <link>http://tanteng.me/2017/05/cgi-fastcgi-php-fpm/</link>
      <pubDate>Thu, 25 May 2017 15:30:33 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/05/cgi-fastcgi-php-fpm/</guid>
      <description>几个链接：
https://www.zhihu.com/question/30672017
http://www.lxlxw.me/?p=216
http://www.tuicool.com/articles/Ir2AreE</description>
    </item>
    
    <item>
      <title>注意 Laravel 清除缓存 php artisan cache:clear 的使用</title>
      <link>http://tanteng.me/2017/05/laravel-cache-clear-warning/</link>
      <pubDate>Tue, 23 May 2017 09:29:27 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/05/laravel-cache-clear-warning/</guid>
      <description>&lt;p&gt;Laravel 的命令 php artisan cache:clear 用来清除各种缓存，如页面，Redis，配置文件等缓存，它会清空 Redis 数据库的全部数据，比如默认使用的 Redis 的数据库是 db0，那么执行这个命令后，会清空 db0 中所有数据。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在 Laravel 中设置 Etag 缓存</title>
      <link>http://tanteng.me/2017/05/laravel-etag-middleware/</link>
      <pubDate>Fri, 19 May 2017 04:51:35 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/05/laravel-etag-middleware/</guid>
      <description>&lt;p&gt;本文介绍浏览器缓存 Etag 的概念，和客户端服务器如何生成和比较 Etag 的过程，以及使用 Laravel 中间件的示例。&lt;/p&gt;

&lt;h3 id=&#34;什么是-etag&#34;&gt;什么是“ETag”？&lt;/h3&gt;

&lt;p&gt;Etag 是一种标识，一般附带在响应头部中，值是页面内容的哈希值，用来判断资源（页面，json，xml）有没有修改，如果没有修改，就返回 304 状态码，有修改则生成新的 Etag 值。&lt;/p&gt;

&lt;p&gt;浏览器根据状态码判断是否缓存过期。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nginx 报错和解决方法记录</title>
      <link>http://tanteng.me/2017/04/nginx-13-permission-denied-111-connection-refused/</link>
      <pubDate>Wed, 19 Apr 2017 07:49:24 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/04/nginx-13-permission-denied-111-connection-refused/</guid>
      <description>&lt;p&gt;记录一下遇到的各种 Nginx 的报错和解决办法。&lt;/p&gt;

&lt;h3 id=&#34;13-permission-denied&#34;&gt;13: Permission denied&lt;/h3&gt;

&lt;p&gt;Nginx错误：&lt;/p&gt;

&lt;p&gt;2017/04/19 14:46:46 [crit] 4172#0: *671 open() &amp;#8220;/data/vhosts/xunlei.com/test/&amp;#8221; failed (13: Permission denied), client: 192.168.35.54, server: www.test.com, request: &amp;#8220;GET / HTTP/1.1&amp;#8221;, host: &amp;#8220;www.test.com&amp;#8221;&lt;/p&gt;

&lt;p&gt;经查权限问题导致，网站目录是 root 用户组，而 nginx 是运行的 nobody 用户进程，修改网站目录为 nobody 用户组。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>韩天峰：2017 年 PHP 程序员未来路在何方</title>
      <link>http://tanteng.me/2017/03/2017-php-way/</link>
      <pubDate>Fri, 31 Mar 2017 07:58:23 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/03/2017-php-way/</guid>
      <description>&lt;p&gt;PHP 从诞生到现在已经有20多年历史，从Web时代兴起到移动互联网退潮，互联网领域各种编程语言和技术层出不穷， Node.js 、 GO 、 Python 不断地在挑战 PHP 的地位。这些技术的推动者非常热衷于唱衰 PHP ， PHP 语言的未来在哪里？PHP 程序员当如何应对未来的变革？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 关联查询返回错误的 id</title>
      <link>http://tanteng.me/2017/03/laravel-model-join-wrong-id/</link>
      <pubDate>Fri, 31 Mar 2017 04:50:37 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/03/laravel-model-join-wrong-id/</guid>
      <description>&lt;p&gt;在 Laravel Eloquent 中使用 join 关联查询，如果两张表有名称相同的字段，如 id，那么它的值会默认被后来的同名字段重写，返回不是期望的结果。例如以下关联查询：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$priority = Priority::rightJoin(&amp;lsquo;touch&amp;rsquo;, &amp;lsquo;priorities.touch_id&amp;rsquo;, &amp;lsquo;=&amp;rsquo;, &amp;lsquo;touch.id&amp;rsquo;)
    -&amp;gt;where(&amp;lsquo;priorities.type&amp;rsquo;, 1)
    -&amp;gt;orderBy(&amp;lsquo;priorities.total_score&amp;rsquo;, &amp;lsquo;desc&amp;rsquo;)
    -&amp;gt;orderBy(&amp;lsquo;touch.created_at&amp;rsquo;, &amp;lsquo;desc&amp;rsquo;)
    -&amp;gt;get();&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP 浮点数范围随机</title>
      <link>http://tanteng.me/2017/03/php-float-rand/</link>
      <pubDate>Wed, 01 Mar 2017 08:59:52 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/03/php-float-rand/</guid>
      <description>PHP 浮点数范围随机代码：
private function frand($min, $max, $decimals = 0) { $scale = pow(10, $decimals); return mt_rand($min * $scale, $max * $scale) / $scale; }
&amp;nbsp;</description>
    </item>
    
    <item>
      <title>如何创建 Laravel 5 扩展包</title>
      <link>http://tanteng.me/2017/02/create-laravel-5-pakage/</link>
      <pubDate>Mon, 20 Feb 2017 08:39:36 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/02/create-laravel-5-pakage/</guid>
      <description>本文介绍了创建 Laravel 5 扩展包的步骤。
链接：
http://laraveldaily.com/how-to-create-a-laravel-5-package-in-10-easy-steps/</description>
    </item>
    
    <item>
      <title>PHP二进制封包</title>
      <link>http://tanteng.me/2017/01/php-pack/</link>
      <pubDate>Thu, 19 Jan 2017 12:41:28 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/01/php-pack/</guid>
      <description>&lt;p&gt;通过 TCP/IP 协议传输数据经常会用二进制数据包的形式，在 PHP 中可使用 pack() 和 unpack() 函数进行二进制封包和解包，通过 socket 建立 TCP 连接，并将数据包传输出去&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Supervisor 管理 Laravel 队列进程</title>
      <link>http://tanteng.me/2017/01/supervisor-laravel-queue/</link>
      <pubDate>Sat, 07 Jan 2017 12:48:53 +0000</pubDate>
      
      <guid>http://tanteng.me/2017/01/supervisor-laravel-queue/</guid>
      <description>&lt;p&gt;Supervisor 是一个 Python 写的进程管理工具，有时一个进程需要在后台运行，并且意外挂掉后能够自动重启，就需要这么一个管理进程的工具。在 Laravel 开发中，也经常使用到队列监听，可以配合 Supervisor 来管理 Laravel 队列进程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 5.3 后台管理系统搭建</title>
      <link>http://tanteng.me/2016/12/laravel-admin-install/</link>
      <pubDate>Sat, 24 Dec 2016 07:13:14 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/12/laravel-admin-install/</guid>
      <description>&lt;p&gt;网上的很多基于 Laravel 的后台管理系统，要么缺少基本的功能，要么太臃肿，总是找不到自己喜欢的，于是自己做了一个。它的特点是尽可能简单又不缺少基本的后台功能，如用户认证，基于角色的权限系统（Entrust），菜单管理，媒体管理等，并且使用 AdminLte 后台界面，外观简洁功能强大。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 使用 env 读取环境变量为 null 的问题</title>
      <link>http://tanteng.me/2016/12/laravel-env-null/</link>
      <pubDate>Sun, 04 Dec 2016 15:35:18 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/12/laravel-env-null/</guid>
      <description>&lt;p&gt;不知道大家有没有遇到过，在 Laravel 中（除 app/config 目录下的配置文件中）使用 env 函数读取环境变量，有时有用，有时返回 null，究竟怎么回事？让我们一探究竟。&lt;/p&gt;

&lt;p&gt;在 Laravel 项目中，如果执行了 php artisan config:cache 命令把配置文件缓存起来后，在 Tinker 中（Tinker 是 Laravel 自带的一个交互式命令行界面），使用 env 函数读取环境变量的值为 null，只有执行 php artisan config:clear 清除配置缓存后就可以读取了，这是为什么呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP数组同值稳定排序</title>
      <link>http://tanteng.me/2016/11/php-array-sort-order/</link>
      <pubDate>Wed, 16 Nov 2016 15:54:43 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/11/php-array-sort-order/</guid>
      <description>&lt;p&gt;在 PHP 中对数组排序有很多函数，如 sort, asort, arsort, ksort, krsort, uasort 等等，但是有一个问题，如一个数组：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;$test = array(1 =&amp;gt; 0, 99 =&amp;gt; 0, 87 =&amp;gt; 0, 45 =&amp;gt; 0, 67 =&amp;gt; 0, 11 =&amp;gt; 1, 2 =&amp;gt; 0);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用 asort 函数对其进行排序，asort($test) 结果如下（转换为 json 格式）：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;{&amp;ldquo;67&amp;rdquo;:0,&amp;ldquo;2&amp;rdquo;:0,&amp;ldquo;1&amp;rdquo;:0,&amp;ldquo;45&amp;rdquo;:0,&amp;ldquo;87&amp;rdquo;:0,&amp;ldquo;99&amp;rdquo;:0,&amp;ldquo;11&amp;rdquo;:1}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到排序虽然正确，值为 1 的元素排到后面去了，但是值为 0 的元素顺序跟以前不一样了，如何保证 PHP 数组同值元素排序后顺序保持不变呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP写文件加锁</title>
      <link>http://tanteng.me/2016/11/flock-write/</link>
      <pubDate>Sun, 13 Nov 2016 14:00:28 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/11/flock-write/</guid>
      <description>&lt;p&gt;用 PHP 的 file_put_contents 函数以追加的方式，循环 10 w 次写文件，耗时很多。因为 file_put_contents 函数每次都要打开文件，写入文件，然后关闭文件。&lt;/p&gt;

&lt;p&gt;以下是测试：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public function handle()
{
    $testTxt = storage_path(&amp;lsquo;test.txt&amp;rsquo;);
    for ($i = 0; $i &amp;lt; 100000; $i++) {
        $this-&amp;gt;comment(&amp;lsquo;writing&amp;hellip;&amp;rsquo;);
        file_put_contents($testTxt, &amp;lsquo;wo shi tanteng.&amp;rsquo; . PHP_EOL, FILE_APPEND);
    }
    $this-&amp;gt;comment(&amp;lsquo;time:&amp;rsquo; . round(microtime(true) - LARAVEL_START, 2));
}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP json_encode 数组键是否从0开始并且连续的区别</title>
      <link>http://tanteng.me/2016/10/php-json-encode-and-decode/</link>
      <pubDate>Fri, 28 Oct 2016 06:39:05 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/10/php-json-encode-and-decode/</guid>
      <description>&lt;p&gt;对以下两个数组进行 json_encode 编码，这两个数组的区别是，一个键是从0开始，并且连续，另一个键不连续，那么打印的结果有什么不同呢？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;print_r(json_encode([
    0 =&amp;gt; 5,
    1 =&amp;gt; 4,
    2 =&amp;gt; 1
]));&lt;/p&gt;

&lt;p&gt;print_r(json_encode([
    0 =&amp;gt; 5,
    1 =&amp;gt; 4,
    5 =&amp;gt; 1
]));&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打印结果：&lt;/p&gt;

&lt;p&gt;[5,4,1]&lt;/p&gt;

&lt;p&gt;{&amp;#8220;0&amp;#8243;:5,&amp;#8221;1&amp;#8243;:4,&amp;#8221;5&amp;#8221;:1}&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel Session 保存机制和 terminate 中间件</title>
      <link>http://tanteng.me/2016/10/laravel-session-middleware/</link>
      <pubDate>Fri, 07 Oct 2016 16:47:38 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/10/laravel-session-middleware/</guid>
      <description>&lt;p&gt;在 Laravel 中可以使用 Session 的 get, put, pull, set, has, flash 等方法进行操作，如：Session::put([&amp;#8216;domain&amp;#8217;=&amp;gt;&amp;#8217;tanteng.me&amp;#8217;, &amp;#8216;host&amp;#8217;=&amp;gt;&amp;#8217;aliyun&amp;#8217;])，就可以设置两个 session 值，看看 put 方法：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34; title=&#34;代码位于vendor/laravel/framework/src/Illuminate/Session/Store.php&#34;&gt;/**
 * Put a key / value pair or array of key / value pairs in the session.
 *
 * @param  string|array  $key
 * @param  mixed       $value
 * @return void
 */
public function put($key, $value = null)
{
    if (! is_array($key)) {
        $key = [$key =&amp;gt; $value];
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach ($key as $arrayKey =&amp;amp;gt; $arrayValue) {
    $this-&amp;amp;gt;set($arrayKey, $arrayValue);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP 遍历元素并分批处理</title>
      <link>http://tanteng.me/2016/10/php-foreach-batch/</link>
      <pubDate>Thu, 06 Oct 2016 10:03:35 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/10/php-foreach-batch/</guid>
      <description>&lt;p&gt;读取一个 txt 文本文件，里面是一行一个 userid，需要给这些用户发送文件（做什么不重要），发送文件接口支持一次最多发 10 个用户，所以需要分批发送，每 10 个 userid 作为一批。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SSO单点登录系统接入</title>
      <link>http://tanteng.me/2016/09/sso-access/</link>
      <pubDate>Fri, 30 Sep 2016 11:55:23 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/09/sso-access/</guid>
      <description>&lt;p&gt;简单讲一下 SSO 单点登录系统的接入的原理，前提是系统本身有完善的用户认证功能，即基本的用户登录功能，那做起来就很方便了。&lt;/p&gt;

&lt;p&gt;SSO 登录请求接口往往是接口加上一个回调地址，访问这个地址会跳转到回调地址并带上一个 ticket 参数，拿着这个 ticket 参数再请求接口可以获取到用户信息，如果存在用户则自动登录，不存在就新增用户并登录。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP捕捉异常中断</title>
      <link>http://tanteng.me/2016/09/register-shutdown-function/</link>
      <pubDate>Wed, 28 Sep 2016 09:31:50 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/09/register-shutdown-function/</guid>
      <description>&lt;p&gt;当 PHP 程序出现异常情况，如出现致命错误，超时，或者不可知的逻辑错误导致程序中断，这个时候可以用 register_shutdown_function 进行异常处理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《性感的 PHP — 现代化 PHP 开发》PPT 分享</title>
      <link>http://tanteng.me/2016/09/modern-php/</link>
      <pubDate>Sun, 25 Sep 2016 14:58:15 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/09/modern-php/</guid>
      <description>&lt;p&gt;说好的把这次技术分享的 PPT 发出来的，一直没时间弄，现在整理了一下，并导出了一份 PDF 版的 PPT，给大家参考。（PS：本次技术分享仅仅是介绍一些关于现代化 PHP 开发的技术，并不是讲某个方面的高深技术和经验，即便如此，针对目前的 PHP 现状，很多项目，公司和开发者，还在使用过时的 PHP 技术，这个分享还是有价值的）。&lt;/p&gt;

&lt;p&gt;本次技术分享主要讲了一些现代化 PHP 开发的技术，PPT 重点介绍了命名空间，闭包，匿名函数，Traits 这些新特性，以及介绍了 Composer 依赖包管理器和 PSR 规范。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP二进制安全</title>
      <link>http://tanteng.me/2016/09/php-binary-safe/</link>
      <pubDate>Sun, 25 Sep 2016 14:33:27 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/09/php-binary-safe/</guid>
      <description>&lt;p&gt;补充一下 PHP 的基础知识，什么是二进制安全？&lt;/p&gt;

&lt;p&gt;这得从 C 语言说起。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C字符串中的字符必须符合某种编码（ 比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾， 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、 音频、 视频、 压缩文件这样的二进制数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上这段文字摘自《Redis设计与实现》。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>友盟 IOS 推送官方 PHP SDK 自定义播示例有误</title>
      <link>http://tanteng.me/2016/09/umeng-ios-php-sdk-customized-wrong/</link>
      <pubDate>Fri, 23 Sep 2016 07:05:14 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/09/umeng-ios-php-sdk-customized-wrong/</guid>
      <description>&lt;p&gt;最近用到友盟给 IOS 应用推送消息，友盟的推送分为单播，列播，广播，组播，文件播，和自定义播，在使用自定义播官方 PHP SDK 发现官方示例（&lt;span class=&#34;version_sel&#34;&gt;PHP SDK v1.4&lt;/span&gt;）有误。&lt;/p&gt;

&lt;p&gt;主要问题，一个是请求 url 需要加 sign 签名，一个是解析数组 json_decode 函数使用问题，还有一个废弃的校验参数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP Fatal error: $this is null</title>
      <link>http://tanteng.me/2016/08/php-fatal-error-this-is-null/</link>
      <pubDate>Thu, 18 Aug 2016 10:40:23 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/08/php-fatal-error-this-is-null/</guid>
      <description>&lt;p&gt;在 PHP 中，一个类的静态方法内部调用自身类的其他方法时必须用 self::method() 的形式，即使静态方法内部方法调用其他方法也是如此，如果使用 $this-&amp;gt;method() 的形式会报错：Fatal error: $this is null in &amp;#8230; xx.php on line xx.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>让你的 Laravel 应用与官方保持同步</title>
      <link>http://tanteng.me/2016/08/laravel-office-sync/</link>
      <pubDate>Wed, 03 Aug 2016 02:55:32 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/08/laravel-office-sync/</guid>
      <description>&lt;p&gt;本文转自安正超博客：&lt;a href=&#34;http://overtrue.me/articles/2015/06/sync-your-laravel-project.html&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;a href=&#34;http://overtrue.me/articles/2015/06/sync-your-laravel-project.html&#34;&gt;http://overtrue.me/articles/2015/06/sync-your-laravel-project.html&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;section&#34;&gt;解决什么问题？&lt;/h2&gt;

&lt;p&gt;我们在用着 4.2，过了一段时间作者发布了 5.0，项目可能还没开发完，然后你又像我一样是一个不升级不舒服斯基，那么用升到最新版是你接下来要忙碌的事情。因为你不知道 4.2 ~ 5.0 变化了多少。所以你不可能手动一个个加上或者删除、修改。有的人可能是备份，然后用新版建立一个项目：&lt;code class=&#34;highlighter-rouge&#34;&gt;composer create-project laravel/laravel&lt;/code&gt; ，然后把原来自己的代码拷过来，然而，变化不一定只是文件新增或者删除啊，可能是原来文件里改了一行，你却没法知道。所以这就头疼了。那么下面我就分享一个超简单的办法来解决这个问题：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 分割 routes.php 路由文件的最佳方式</title>
      <link>http://tanteng.me/2016/08/laravel-routes-map/</link>
      <pubDate>Tue, 02 Aug 2016 09:20:26 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/08/laravel-routes-map/</guid>
      <description>&lt;p&gt;Laravel 的路由功能很强大，路由规则默认都定义在 routes.php 文件中，但是随着项目越来越大，我们需要的定义的规则越来越多，如果几百上千个路由都定义在一个文件中，如何去维护？如果不同的人都在同一个文件定义路由，这就造成了冲突，因此我们有必要将 routes.php 文件分割成多个文件，可以按照功能模块来划分，下面介绍一种很优雅的方式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 调试工具 laravel-debugbar 打印日志消息</title>
      <link>http://tanteng.me/2016/08/laravel-debugbar-facade/</link>
      <pubDate>Mon, 01 Aug 2016 15:57:59 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/08/laravel-debugbar-facade/</guid>
      <description>&lt;p&gt;使用 Laravel 的调试工具 laravel-debugbar 的 Facade 方式 Debugbar::info(), Debugbar::error()等方法打印日志消息，页面打不开，查看 PHP 错误日志报错：Call to undefined method DebugBar\DebugBar::info().&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 调试工具 laravel-debugbar</title>
      <link>http://tanteng.me/2016/08/laravel-debugbar-sql/</link>
      <pubDate>Mon, 01 Aug 2016 13:10:38 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/08/laravel-debugbar-sql/</guid>
      <description>&lt;p&gt;给 Laravel 项目安装了 debugbar 调试工具，在 debug 模式下打开页面底部会出现一个工具条，点开可以查看各项性能统计，最重要的是打印页面执行的 sql 语句和调试内容。下面利用 debugbar 工具找到一个 sql 查询的优化点。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP 7 性能洞察，一张图告诉你</title>
      <link>http://tanteng.me/2016/07/php7-performance-inisight-into/</link>
      <pubDate>Fri, 29 Jul 2016 03:23:06 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/07/php7-performance-inisight-into/</guid>
      <description>&lt;p&gt;PHP 7 发布，最大的特点是经过很多优化性能得到大幅提升，几乎翻倍，甚至比 Facebook 开发的 HHVM 虚拟机性能更快，下面这张图对比了 PHP 5.6，HHVM 和 PHP 7 下的性能对比，带你洞察 PHP 7 的性能。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>判断PHP的exec函数是否执行成功</title>
      <link>http://tanteng.me/2016/07/php-exec-status/</link>
      <pubDate>Thu, 21 Jul 2016 13:14:54 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/07/php-exec-status/</guid>
      <description>&lt;p class=&#34;refname&#34;&gt;
  做一个代码发布的系统，需要用到PHP的exec函数来执行Linux下的命令和git，svn命令，如何判断PHP的exec函数是否执行成功呢？
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>提交PHP组件到Packagist 发布自己的Composer包</title>
      <link>http://tanteng.me/2016/07/submit-composer-packagist/</link>
      <pubDate>Wed, 13 Jul 2016 04:04:53 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/07/submit-composer-packagist/</guid>
      <description>&lt;p&gt;Composer是PHP的一个依赖管理工具，它使得PHP焕发新的生机，有了现代化的WEB开发规范，Packagist是PHP组件的库，也有其他的镜像。&lt;/p&gt;

&lt;p&gt;在Packagist上提交了一个自己开发的PHP组件，这样其他开发者就可以使用Composer使用这个包了。这个组件并没什么功能，主要是看看提交PHP组件的流程，并记录了过程中遇到的问题及解决方法，以供参考。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 5.2 队列的配置和使用</title>
      <link>http://tanteng.me/2016/07/laravel-5-queue/</link>
      <pubDate>Sun, 10 Jul 2016 10:14:21 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/07/laravel-5-queue/</guid>
      <description>&lt;p&gt;队列常常用于两种场景，一种是高并发的情况，一种是耗时的操作，可以将任务放到队列中去，消费者从队列取任务执行，当然还有失败的情况如何处理，以及延迟，重试，更复杂的情况还有优先级的实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>解决一个SSRF漏洞</title>
      <link>http://tanteng.me/2016/07/ssrf-shell/</link>
      <pubDate>Thu, 07 Jul 2016 10:39:23 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/07/ssrf-shell/</guid>
      <description>&lt;p&gt;乌云平台检测出一个SSRF漏洞，漏洞存在于一个远程图片下载的接口，没有对url进行有效的合法性检测。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.tanteng.me/wp-content/uploads/2016/07/ssrf.png&#34; target=&#34;_blank&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-10191&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2016/07/ssrf.png&#34; alt=&#34;ssrf&#34; width=&#34;900&#34; height=&#34;537&#34; /&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP Curl 上传文件</title>
      <link>http://tanteng.me/2016/06/php-curl-post-send-file/</link>
      <pubDate>Thu, 30 Jun 2016 03:29:42 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/06/php-curl-post-send-file/</guid>
      <description>记录一个 curl 示例，代码如下：
function curl($file, $targetUrl) { if (function_exists(&amp;lsquo;curl_file_create&amp;rsquo;)) { // php 5.5+ $cFile = curl_file_create($file); } else { // $cFile = &amp;lsquo;@&amp;rsquo; . realpath($file); } $post = array(&amp;lsquo;filename&amp;rsquo; =&amp;gt; $cFile); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $targetUrl); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $post); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $result = curl_exec($ch); curl_close($ch); return $result; }
检测 curl_file_create 函数是为了兼容 PHP 以前版本。CURLOPT_RETURNTRANSFER 参数表示 curl_exec 返回接口原始内容。CURLOPT_POSTFIELDS 是 post 的内容。</description>
    </item>
    
    <item>
      <title>执行sh脚本：/bin/sh^M: bad interpreter: No such file or directory</title>
      <link>http://tanteng.me/2016/06/binshm-bad-interpreter-no-file-directory/</link>
      <pubDate>Tue, 21 Jun 2016 07:59:57 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/06/binshm-bad-interpreter-no-file-directory/</guid>
      <description>&lt;p&gt;执行sh脚本错误：/bin/sh^M: bad interpreter: No such file or directory，这是windows下编码不同造成的，在Linux下修复方法如下，记录一下。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel Elixir运行gulp命令:Error in plugin ‘gulp-notify’</title>
      <link>http://tanteng.me/2016/06/gulp-notify-notify-send-must-be-installed/</link>
      <pubDate>Mon, 20 Jun 2016 12:58:36 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/06/gulp-notify-notify-send-must-be-installed/</guid>
      <description>&lt;p&gt;Laravel Elixir运行gulp命令出现错误提示：&lt;/p&gt;

&lt;p&gt;[20:24:02] gulp-notify: [Error in notifier] Error in plugin &amp;#8216;gulp-notify&amp;#8217;&lt;/p&gt;

&lt;p&gt;Message:notify-send must be installed on the system.&lt;/p&gt;

&lt;p&gt;虽然不影响最终的发布，但是还是解决这个问题。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP 7安装和开启opcache</title>
      <link>http://tanteng.me/2016/06/php7-opcache/</link>
      <pubDate>Thu, 02 Jun 2016 16:20:20 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/06/php7-opcache/</guid>
      <description>&lt;p&gt;鸟哥在博客中说，提高PHP 7性能的几个tips，第一条就是开启opache，引用下原文：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;记得启用Zend Opcache, 因为PHP7即使不启用Opcache速度也比PHP-5.6启用了Opcache快, 所以之前测试时期就发生了有人一直没有启用Opcache的事情&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>优化 Laravel 网站打开速度</title>
      <link>http://tanteng.me/2016/06/laravel-optimize/</link>
      <pubDate>Thu, 02 Jun 2016 11:59:07 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/06/laravel-optimize/</guid>
      <description>&lt;p&gt;Laravel是一个功能强大的框架，组件很多，代码也很庞大，它的易用方便是牺牲了性能的，即便如此它仍然是一个优秀的框架，但在正式环境下要做好优化提升网站的打开速度。&lt;/p&gt;

&lt;h3 id=&#34;1-关闭debug&#34;&gt;1.关闭debug&lt;/h3&gt;

&lt;p&gt;打开.env文件，把debug设置为false.&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;APP_ENV=local
APP_DEBUG=false
APP_KEY=base64:sT/aTFeaE13eyao1Raee6jC9Ff+Yle1SE+wtyk0H6B4=&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-缓存路由和配置&#34;&gt;2.缓存路由和配置&lt;/h3&gt;

&lt;p&gt;php artisan route:cache&lt;/p&gt;

&lt;p&gt;php artisan config:cache&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>preg_replace_callback用法</title>
      <link>http://tanteng.me/2016/05/preg_replace_callback-usage/</link>
      <pubDate>Sat, 28 May 2016 09:53:32 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/05/preg_replace_callback-usage/</guid>
      <description>&lt;p&gt;preg_replace_callback一般用于正则替换，三个参数，第一个参数正则表达式，第二个参数回调函数，第三个参数是要替换的内容。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Crontab部署计划任务注意事项</title>
      <link>http://tanteng.me/2016/05/crontab-task-note/</link>
      <pubDate>Wed, 18 May 2016 08:28:17 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/05/crontab-task-note/</guid>
      <description>&lt;p&gt;使用Crontab部署计划任务，有几个地方需要注意。&lt;/p&gt;

&lt;p&gt;1.每3小时执行一次，不是* */3 * * *,这样还是每分钟执行一次，应该是0 */3 * * *.&lt;/p&gt;

&lt;p&gt;2.Crontab运行的文件必须要有可执行权限，给文件添加可执行文件的方法：chmod +x filename.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>set_include_path和require,include</title>
      <link>http://tanteng.me/2016/05/set_include_path-require/</link>
      <pubDate>Wed, 04 May 2016 04:04:53 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/05/set_include_path-require/</guid>
      <description>&lt;p&gt;在PHP中经常使用include，require来引用其他文件，使用相对路径或者绝对路径，如果通过set_include_path函数或者ini_set(&amp;#8216;include_path&amp;#8217;,xxx)设置include_path配置选项，那么require文件如果在其他目录也可以直接引用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Crontab定时任务实例</title>
      <link>http://tanteng.me/2016/05/crontab-sample/</link>
      <pubDate>Tue, 03 May 2016 12:46:28 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/05/crontab-sample/</guid>
      <description>&lt;p&gt;Linux系统使用Crontab跑计划任务，也就是定时任务，基本的语法格式是：&lt;/p&gt;

&lt;p&gt;2 */1 * * * /data/vhosts/example/cronjob/_run_1_hour.sh&lt;/p&gt;

&lt;p&gt;可以在一个sh脚本中指定执行一个或多个PHP脚本，当然也可以直接用PHP解释器运行PHP脚本。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:sh decode:true &#34;&gt;#!/bin/sh
cd /data/vhosts/web/cronjob
RUNPATH=/data/vhosts/web/cronjob
PHPEXEC=/usr/local/php-fcgi/bin/php&lt;/p&gt;

&lt;h1 id=&#34;每小时运行一次此脚本&#34;&gt;每小时运行一次此脚本&lt;/h1&gt;

&lt;p&gt;$PHPEXEC $RUNPATH/test_crontab.php&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Composer设置忽略版本匹配</title>
      <link>http://tanteng.me/2016/04/composer-ignore-reqs/</link>
      <pubDate>Tue, 26 Apr 2016 16:15:08 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/04/composer-ignore-reqs/</guid>
      <description>&lt;p&gt;执行composer install遇到错误：Your requirements could not be resolved to an installable set of packages. 这是因为不匹配composer.json要求的版本。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nginx 设置 $_SERVER 变量</title>
      <link>http://tanteng.me/2016/04/nginx-set-fastcgi-param/</link>
      <pubDate>Wed, 13 Apr 2016 10:58:09 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/04/nginx-set-fastcgi-param/</guid>
      <description>&lt;p&gt;在有的PHP中定义ENVIRONMENT常量，可以区分开发环境和生产环境，如：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;define(&amp;lsquo;ENVIRONMENT&amp;rsquo;, isset($_SERVER[&amp;lsquo;CI_ENV&amp;rsquo;]) ? $_SERVER[&amp;lsquo;CI_ENV&amp;rsquo;] : &amp;lsquo;development&amp;rsquo;);
switch (ENVIRONMENT)
{
    case &amp;lsquo;development&amp;rsquo;:
        error_reporting(-1);
        ini_set(&amp;lsquo;display_errors&amp;rsquo;, 1);
    break;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case &#39;testing&#39;:
case &#39;production&#39;:
    ini_set(&#39;display_errors&#39;, 0);
    if (version_compare(PHP_VERSION, &#39;5.3&#39;, &#39;&amp;amp;gt;=&#39;))
    {
        error_reporting(E_ALL &amp;amp; ~E_NOTICE &amp;amp; ~E_DEPRECATED &amp;amp; ~E_STRICT &amp;amp; ~E_USER_NOTICE &amp;amp; ~E_USER_DEPRECATED);
    }
    else
    {
        error_reporting(E_ALL &amp;amp; ~E_NOTICE &amp;amp; ~E_STRICT &amp;amp; ~E_USER_NOTICE);
    }
break;

default:
    header(&#39;HTTP/1.1 503 Service Unavailable.&#39;, TRUE, 503);
    echo &#39;The application environment is not set correctly.&#39;;
    exit(1); // EXIT_ERROR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>巧用vagrant建立映射目录解决环境兼容问题</title>
      <link>http://tanteng.me/2016/04/vagrantfile-synced-folder/</link>
      <pubDate>Fri, 08 Apr 2016 14:12:34 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/04/vagrantfile-synced-folder/</guid>
      <description>&lt;p&gt;使用Vagrant装虚拟机的童鞋应该知道在Vagrantfile文件中可以定义本机和虚拟机目录映射，如：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;config.vm.synced_folder &amp;quot;../website&amp;quot;, &amp;quot;/usr/share/nginx/html&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;表示把本机的当前文件目录下website目录映射到虚拟机的指定目录，这样在虚拟机中该目录的内容即是website目录下的，也就是实现了目录共享。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mac上安装Homestead</title>
      <link>http://tanteng.me/2016/04/homestead/</link>
      <pubDate>Sun, 03 Apr 2016 10:12:00 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/04/homestead/</guid>
      <description>&lt;p&gt;之前在Windows上用VirtualBox+Vagrant装了一个CentOS 7的虚拟机，回家后又把Mac上的PHP集成开发环境MAMP给卸载了，也用VirtualBox+Vagrant装一个虚拟机，这次用的是Laravel官方封装好的box——Homestead.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux命令alias和ln（别名和链接命令）</title>
      <link>http://tanteng.me/2016/03/linux-alias-ln/</link>
      <pubDate>Sun, 27 Mar 2016 12:24:31 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/03/linux-alias-ln/</guid>
      <description>&lt;p&gt;今天遇到个问题，我用 yum 的方式安装的 php7 的环境，包括 nginx ， php-fpm 等，使用的是 remi 源，安装成功，但是 PHP 的全局环境变量是 php70 ，也就是说在终端本来命令 php 是可用的，现在必须是 php70 了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用VirtualBox&#43;Vagrant安装CentOS 7环境</title>
      <link>http://tanteng.me/2016/03/windows-virtualbox-vagrant-centos7/</link>
      <pubDate>Thu, 24 Mar 2016 08:08:55 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/03/windows-virtualbox-vagrant-centos7/</guid>
      <description>&lt;p&gt;在Windows上使用VirtualBox+Vagrant安装CentOS 7环境，需要安装VirtualBox和Vagrant工具，以及下载一个CentOS 7的box镜像文件。&lt;/p&gt;

&lt;p&gt;一、安装好以上工具，下载好box文件后，使用vagrant命令添加镜像到Vagrant：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:vim decode:true&#34;&gt;vagrant box add 名称 路径&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里成功添加镜像到Vagrant，如下：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone wp-image-9724 size-full&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2016/03/vagrant_box_add.png&#34; alt=&#34;vagrant_box_add&#34; width=&#34;603&#34; height=&#34;109&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel集成WordPress扩展包——Corcel</title>
      <link>http://tanteng.me/2016/03/laravel-wordpress-corcel/</link>
      <pubDate>Sun, 20 Mar 2016 04:29:43 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/03/laravel-wordpress-corcel/</guid>
      <description>&lt;p&gt;Corcel是一个可以适用于Laravel框架的集成Wordpress的扩展包，使用wordpress的后台发布文章，通过它的接口可以在Laravel中方便的调取文章等，安装和使用也非常简单。&lt;/p&gt;

&lt;p&gt;Corcel的Github地址：&lt;a href=&#34;https://github.com/jgrossi/corcel&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;&lt;a href=&#34;https://github.com/jgrossi/corcel&#34;&gt;https://github.com/jgrossi/corcel&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里讲一下大概的过程，具体的安装和使用见github主页上的说明。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>配置nginx 301跳转到www域</title>
      <link>http://tanteng.me/2016/03/nginx-301/</link>
      <pubDate>Wed, 16 Mar 2016 15:34:13 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/03/nginx-301/</guid>
      <description>&lt;p&gt;如一个网站www.tanteng.me，域名解析的时候配置www.tanteng.me和tanteng.me都指向一个A记录，这两个域名都可以访问，但是这样会有一些弊端，详见：&lt;a href=&#34;https://www.zhihu.com/question/20414602&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;为什么越来越多的网站域名不加 ‘www’ 前缀？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如何在nginx中配置，当访问&lt;a href=&#34;https://www.tanteng.me&#34; target=&#34;_blank&#34;&gt;tanteng.me&lt;/a&gt;的时候自动301跳转到&lt;a href=&#34;https://www.tanteng.me&#34; target=&#34;_blank&#34;&gt;www.tanteng.me&lt;/a&gt;呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>理解RESTful架构</title>
      <link>http://tanteng.me/2016/03/restful/</link>
      <pubDate>Wed, 09 Mar 2016 02:17:10 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/03/restful/</guid>
      <description>什么是RESTful架构？如何理解RESTFul？了解RESTFul的URL表现形式。
链接：http://www.ruanyifeng.com/blog/2011/09/restful</description>
    </item>
    
    <item>
      <title>PHP闭包函数传参及使用外部变量</title>
      <link>http://tanteng.me/2016/03/php-closure-use/</link>
      <pubDate>Tue, 08 Mar 2016 04:14:17 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/03/php-closure-use/</guid>
      <description>&lt;p&gt;在Laravel控制器写两个方法，一个是在内部创建一个闭包函数，一个是执行传过来的闭包函数，测试闭包的写法，use使用外部变量，及闭包函数的传参。如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;//测试闭包传参及use使用外部变量
public function testClosure($t1, $t2)
{
    $closure = function ($param1, $param2) use ($t1, $t2) {
        echo $param1.$param2.$t1.$t2;
    };
    $this-&amp;gt;execClosure(&amp;lsquo;test.closure&amp;rsquo;, $closure);
}&lt;/p&gt;

&lt;p&gt;//执行闭包函数
protected function execClosure($name, Closure $closure)
{
    echo &amp;lsquo;Closure func name:&amp;lsquo;.$name;
    echo &amp;lsquo;&amp;lt;br&amp;gt;&amp;rsquo;;
    $closure(&amp;lsquo;p1&amp;rsquo;, &amp;lsquo;p2&amp;rsquo;);
}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel Nginx配置示例</title>
      <link>http://tanteng.me/2016/02/laravel-nginx-server-conf/</link>
      <pubDate>Sat, 20 Feb 2016 16:43:57 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/02/laravel-nginx-server-conf/</guid>
      <description>&lt;p&gt;这是一个Laravel框架运行nginx服务器的配置示例，Laravel框架版本5.2&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel 5.2自带用户注册和登录认证</title>
      <link>http://tanteng.me/2016/02/laravel-5-2-auth/</link>
      <pubDate>Fri, 19 Feb 2016 07:14:06 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/02/laravel-5-2-auth/</guid>
      <description>&lt;p&gt;Laravel 5.2自带用户注册和登录认证，安装好Laravel后，在app根目录执行php artisan make:auth,即可自动安装一个简易的功能完整的用户认证系统。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone wp-image-9509 size-full&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2016/02/laravel-login.png&#34; alt=&#34;laravel-login&#34; width=&#34;750&#34; height=&#34;460&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel维护模式的实现原理</title>
      <link>http://tanteng.me/2016/02/laravel-maintenance/</link>
      <pubDate>Thu, 18 Feb 2016 14:35:06 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/02/laravel-maintenance/</guid>
      <description>&lt;p&gt;Laravel开启维护模式的方法是：php artisan down,关闭维护模式的命令是：php artisan up，当开启维护模式后，打开网站任何链接都提示“维护中”，当然这是可自定义的，并且返回503的HTTP码，这其实就是通过中间件来实现的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CentOS 7 安装 PHP 7</title>
      <link>http://tanteng.me/2016/02/centos-yum-install-php7/</link>
      <pubDate>Wed, 03 Feb 2016 09:53:28 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/02/centos-yum-install-php7/</guid>
      <description>&lt;p&gt;在centos7通过yum安装PHP7，首先在终端运行：&lt;/p&gt;

&lt;p&gt;rpm -Uvh &lt;a href=&#34;https://mirror.webtatic.com/yum/el7/webtatic-release.rpm&#34;&gt;https://mirror.webtatic.com/yum/el7/webtatic-release.rpm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;提示错误：&lt;/p&gt;

&lt;p&gt;error: Failed dependencies:&lt;/p&gt;

&lt;p&gt;epel-release &amp;gt;= 7 is needed by webtatic-release-7-3.noarch&lt;/p&gt;

&lt;p&gt;需要先安装epel-release。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MySQL 字符串字段转换 crc32 建索引提高查询效率</title>
      <link>http://tanteng.me/2016/02/crc32-mysql-index/</link>
      <pubDate>Mon, 01 Feb 2016 01:29:07 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/02/crc32-mysql-index/</guid>
      <description>&lt;p&gt;给字符串类型的字段建立索引效率不高，但是必须要经常查这个字段怎么建索引？比如这个字段名称是 sys_trans_id 字符串类型，那么可以建一个字段 sys_trans_id_src32 来存储 crc32 的值，并给这个字段建立索引。&lt;/p&gt;

&lt;p&gt;crc32 是整形，在MySQL中，给整形字段建立索引效率比较高，crc32虽然不能确保唯一性，但是无碍，相同的机率也是极小，关键是可以大大减少查询的范围，给sys_trans_id_src32 这个字段建立索引，查询的时候带上 crc32 字段就可以利用到索引。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel Ioc容器singleton和bind方法的区别</title>
      <link>http://tanteng.me/2016/01/laravel-singleton-bind/</link>
      <pubDate>Fri, 29 Jan 2016 06:06:19 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/01/laravel-singleton-bind/</guid>
      <description>&lt;p&gt;Laravel中使用Ioc容器的singleton方法和bind方法创建实例有什么区别呢？它们两个都是返回一个类的实例，不同的是singleton是单例模式，而bind是每次返回一个新的实例，看下面的两个例子。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP GOTO语法</title>
      <link>http://tanteng.me/2016/01/php-goto/</link>
      <pubDate>Thu, 28 Jan 2016 10:47:43 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/01/php-goto/</guid>
      <description>PHP的GOTO语法可以跳转到指定位置，如代码所示，goto display，在代码后面定义了一个display:,这样当执行goto display语句时，会跳到定义display的地方开始执行，这是PHP5.3增加的语法，支持PHP7.
public function index() { if (!I(&amp;lsquo;get.search&amp;rsquo;)) { goto display; }
//此处省略800字 $this-&amp;amp;gt;assign(&#39;account&#39;, self::$account); $this-&amp;amp;gt;assign(&#39;pay_type&#39;, I(&#39;get.pay_type&#39;)); $this-&amp;amp;gt;assign(&#39;list&#39;, $list); display: $this-&amp;amp;gt;display();  }
&amp;nbsp;</description>
    </item>
    
    <item>
      <title>Laravel构造函数自动依赖注入</title>
      <link>http://tanteng.me/2016/01/laravel-construct-ioc/</link>
      <pubDate>Thu, 28 Jan 2016 05:59:41 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/01/laravel-construct-ioc/</guid>
      <description>&lt;p&gt;在Laravel的构造函数中可以实现自动依赖注入，而不需要实例化之前先实例化需要的类，如代码所示：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;&amp;lt;?php
namespace Lio\Http\Controllers\Forum;&lt;/p&gt;

&lt;p&gt;use Lio\Forum\Replies\ReplyRepository;
use Lio\Forum\Threads\ThreadCreator;
use Lio\Forum\Threads\ThreadCreatorListener;
use Lio\Forum\Threads\ThreadDeleterListener;
use Lio\Forum\Threads\ThreadForm;
use Lio\Forum\Threads\ThreadRepository;
use Lio\Forum\Threads\ThreadUpdaterListener;
use Lio\Http\Controllers\Controller;
use Lio\Tags\TagRepository;&lt;/p&gt;

&lt;p&gt;class ForumThreadsController extends Controller implements ThreadCreatorListener, ThreadUpdaterListener, ThreadDeleterListener
{
    protected $threads;
    protected $tags;
    protected $currentSection;
    protected $threadCreator;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function __construct(
    ThreadRepository $threads,
    ReplyRepository $replies,
    TagRepository $tags,
    ThreadCreator $threadCreator
) {
    $this-&amp;amp;gt;threads = $threads;
    $this-&amp;amp;gt;tags = $tags;
    $this-&amp;amp;gt;threadCreator = $threadCreator;
    $this-&amp;amp;gt;replies = $replies;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在Laravel中注册Facades的步骤</title>
      <link>http://tanteng.me/2016/01/laravel-facades-register/</link>
      <pubDate>Wed, 27 Jan 2016 06:42:52 +0000</pubDate>
      
      <guid>http://tanteng.me/2016/01/laravel-facades-register/</guid>
      <description>&lt;p&gt;在Laravel中将类注册为Fcade可以使用Ioc容器，每次使用这个类的时候只会初始化一次类，类似单例模式，而且可以像使用静态方法调用类的方法，下面是在Laravel中注册Facades的步骤。&lt;/p&gt;

&lt;p&gt;1.在项目app目录的Providers/AppServiceProvider.php中的register方法新增方法，代码如下。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Composer的自动加载机制</title>
      <link>http://tanteng.me/2015/12/composer-autoload/</link>
      <pubDate>Thu, 24 Dec 2015 15:41:16 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/12/composer-autoload/</guid>
      <description>&lt;p&gt;如项目下的composer.json文件中有autoload的定义：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;&amp;ldquo;autoload&amp;rdquo;: {
        &amp;ldquo;classmap&amp;rdquo;: [
            &amp;ldquo;database&amp;rdquo;
        ],
        &amp;ldquo;psr-4&amp;rdquo;: {
            &amp;ldquo;GrahamCampbell\BootstrapCMS\&amp;ldquo;: &amp;ldquo;app/&amp;rdquo;
        }
    },&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样定义如何实现自动加载呢？这里classmap和psr-4的区别又是什么？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Laravel中Trait的使用</title>
      <link>http://tanteng.me/2015/12/laravel-trait/</link>
      <pubDate>Mon, 21 Dec 2015 14:03:18 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/12/laravel-trait/</guid>
      <description>&lt;p&gt;看看PHP官方手册对Trait的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p class=&#34;para&#34;&gt;
  自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。
&lt;/p&gt;

&lt;p class=&#34;para&#34;&gt;
  Traits 是一种为类似 PHP 的单继承语言而准备的代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用方法集。Traits 和类组合的语义是定义了一种方式来减少复杂性，避免传统多继承和混入类（Mixin）相关的典型问题。
&lt;/p&gt;

&lt;p class=&#34;para&#34;&gt;
  Trait 和一个类相似，但仅仅旨在用细粒度和一致的方式来组合功能。Trait 不能通过它自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用类的成员不需要继承。
&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Laravel 执行 migrate 命令:No such file or directory</title>
      <link>http://tanteng.me/2015/12/laravel-migrate-mysql-2000/</link>
      <pubDate>Sun, 20 Dec 2015 09:50:22 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/12/laravel-migrate-mysql-2000/</guid>
      <description>&lt;p&gt;今天使用Laravel命令行工具操作数据库迁移操作时报错，提示mysql 2002错误，如图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.tanteng.me/wp-content/uploads/2015/12/artisan-migrate-PDOException.png&#34; rel=&#34;attachment wp-att-9354&#34; target=&#34;_blank&#34;&gt;&lt;img class=&#34;alignnone wp-image-9354&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2015/12/artisan-migrate-PDOException.png&#34; alt=&#34;artisan-migrate-PDOException&#34; width=&#34;420&#34; height=&#34;118&#34; /&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>httpd-vhosts设置域名别名</title>
      <link>http://tanteng.me/2015/11/httpd-vhost-domain-alias/</link>
      <pubDate>Thu, 19 Nov 2015 06:24:43 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/11/httpd-vhost-domain-alias/</guid>
      <description>&lt;p&gt;在Apache的httpd-vhosts可以配置虚拟主机域名，也可以设置域名别名，如域名www.yii2.com，可以给它设置一个或多个域名别名，通过www.yii3.com,www.yii4.com访问。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP中serialize和json序列化与反序列化的区别</title>
      <link>http://tanteng.me/2015/11/serialize-json-diff/</link>
      <pubDate>Thu, 12 Nov 2015 06:53:20 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/11/serialize-json-diff/</guid>
      <description>&lt;p&gt;在PHP中，serialize和json两种方式对一个对象或数组进行序列化或反序列化有什么区别呢？&lt;/p&gt;

&lt;p&gt;假设一个对象和一个数组：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;$web = new stdClass;
$web-&amp;gt;site = &amp;lsquo;tantengvip&amp;rsquo;;
$web-&amp;gt;owner = &amp;lsquo;tuntun&amp;rsquo;;
$web-&amp;gt;age = 5;&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP中stdClass的意义</title>
      <link>http://tanteng.me/2015/11/php-stdclass/</link>
      <pubDate>Sun, 08 Nov 2015 13:38:38 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/11/php-stdclass/</guid>
      <description>&lt;p&gt;在WordPress中很多地方使用stdClass来定义一个对象（而通常是用数组的方式），然后使用get_object_vars来把定义的对象『转换』成数组。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>微信打赏WordPress插件</title>
      <link>http://tanteng.me/2015/11/wechat-rewrd-wordpress-plugin/</link>
      <pubDate>Wed, 04 Nov 2015 05:58:01 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/11/wechat-rewrd-wordpress-plugin/</guid>
      <description>&lt;p&gt;折腾了一个WordPress小插件，给每篇文章下面添加一个微信打赏功能，安装插件后，可在后台设置自己的微信收款二维码图片。&lt;/p&gt;

&lt;h3 id=&#34;后台设置页面&#34;&gt;后台设置页面&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.tanteng.me/wp-content/uploads/2015/11/wechat-reward16.png&#34; target=&#34;_blank&#34;&gt;&lt;img class=&#34;alignnone wp-image-8841 size-full&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2015/11/wechat-reward16.png&#34; alt=&#34;wechat-reward16&#34; width=&#34;946&#34; height=&#34;436&#34; srcset=&#34;https://blog.tanteng.me/wp-content/uploads/2015/11/wechat-reward16.png 946w, https://blog.tanteng.me/wp-content/uploads/2015/11/wechat-reward16-300x138.png 300w&#34; sizes=&#34;(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Redis加锁防止重复操作的原理</title>
      <link>http://tanteng.me/2015/11/redis-lock-incr/</link>
      <pubDate>Mon, 02 Nov 2015 03:23:57 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/11/redis-lock-incr/</guid>
      <description>&lt;p&gt;使用Redis加锁的方式可以防止重复操作，包括表单提交，ajax等http请求，它的原理就是redis的incr命令给键自增，如果返回值不是1，就表示是重复请求，具体看代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/**
 * 锁定请求
 * @param int $expire 锁定时间
 * @param string $mark 自定义标记
 * @return bool
 */
protected function lock($expire=1,$mark=&amp;ldquo;){
    $url=strtolower(MODULE_NAME.&amp;lsquo;/&amp;rsquo;.ACTION&lt;em&gt;NAME);//操作地址
    $prefix=&amp;lsquo;lock&lt;/em&gt;&amp;rsquo;;$sid=$_COOKIE[C(&amp;ldquo;SESSION_OPTIONS.name&amp;rdquo;)];
    $key=$prefix.md5($sid.$url.$mark);//令牌键值
    /**
     * @var Redis $redis
     */
    $redis = D(&amp;lsquo;Redis&amp;rsquo;);
    if($redis-&amp;gt;incr($key)==1){
        return $redis-&amp;gt;expire($key,$expire);
    }
    return false;
}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>call_user_func与实例化的区别</title>
      <link>http://tanteng.me/2015/10/call-user-func-vs-new-class/</link>
      <pubDate>Fri, 30 Oct 2015 10:43:23 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/10/call-user-func-vs-new-class/</guid>
      <description>&lt;p&gt;使用call_user_func可以执行一个类的某个方法，而且可以给方法传参数，它跟实例化一个类再调用方法有什么区别呢？看下面的例子。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;class A
{
    public function __Construct($a,$b,$c)
    {
        echo &amp;lsquo;Construct&amp;rsquo;.$a.$b.$c;
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function test($a,$b,$c)
{
    echo &#39; test&#39;.$a.$b.$c;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;$a = new A(1,2,3);
$a-&amp;gt;test(1,2,3);&lt;/p&gt;

&lt;p&gt;call_user_func([&amp;lsquo;A&amp;rsquo;,&amp;lsquo;test&amp;rsquo;],1,2,3);&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP反射类ReflectionClass</title>
      <link>http://tanteng.me/2015/10/php-reflectionclass/</link>
      <pubDate>Fri, 30 Oct 2015 02:46:56 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/10/php-reflectionclass/</guid>
      <description>&lt;p class=&#34;lang:php decode:true &#34;&gt;
  首先定义一个类A，用ReflectionClass得到A的反射类对象，通过ReflectionClass对象可以得到类的各种属性，包括命名空间，父类，类名等，使用newInstanceArgs可以传入构造函数的参数创建一个新的类的实例。
&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class A
{
    public $name;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function __Construct($name,$des)
{
    $this-&amp;amp;gt;name = $name.&#39;,&#39;.$des;
}
public function aa()
{
    echo $this-&amp;amp;gt;name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;$class = new ReflectionClass(&amp;lsquo;A&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;$aaa = $class-&amp;gt;newInstanceArgs([&amp;lsquo;blog.tanteng.me&amp;rsquo;,&amp;lsquo;blog&amp;rsquo;]);&lt;/p&gt;

&lt;p&gt;$aaa-&amp;gt;aa();&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP约束参数类型</title>
      <link>http://tanteng.me/2015/10/php-oop-typehinting/</link>
      <pubDate>Thu, 29 Oct 2015 03:10:33 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/10/php-oop-typehinting/</guid>
      <description>&lt;p&gt;PHP5起可以约束参数类型，在Yii2框架中使用很多，可以指定一个类的方法或者函数参数必须是某个类型，类型可以是对象，数组，字符串，整形。如果指定了参数类型，那么传入的值必须是符合类型约束的，否则会报异常错误。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>写一个PHP单例模式的类</title>
      <link>http://tanteng.me/2015/10/php-simple-singleton-pattern-class/</link>
      <pubDate>Sun, 25 Oct 2015 10:24:12 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/10/php-simple-singleton-pattern-class/</guid>
      <description>&lt;p&gt;最近为了解决一个问题，需要写一个PHP的单例模式的类，以前也小有研究，其实项目中包括框架自身许多地方也是使用的单例模式，但没自己写过，于是自己随手写了一个实现单机模式的简单类。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何防止ajax重复提交</title>
      <link>http://tanteng.me/2015/10/redis-jquery-ajax/</link>
      <pubDate>Sun, 25 Oct 2015 07:00:21 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/10/redis-jquery-ajax/</guid>
      <description>&lt;p&gt;关于防止重复提交，可以参考如下链接：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.tanteng.me/2015/08/redis-lock/&#34; target=&#34;_blank&#34;&gt;使用Redis加锁防止重复提交&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.tanteng.me/2015/07/form-submit/&#34; target=&#34;_blank&#34;&gt;防止表单重复提交的几种方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.tanteng.me/2015/05/js-lock/&#34; target=&#34;_blank&#34;&gt;jquery的data方法用法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文讲讲如何使用redis和jquery防止ajax重复提交，如果按钮是button，点击按钮之后，js使按钮禁用，程序那边同时也加锁即可。如果按钮是a标签，则需要使用jquery的data方法在页面上加锁，具体方法见上面第3个链接。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP数组array_merge和&#43;的区别</title>
      <link>http://tanteng.me/2015/10/php-array-merge/</link>
      <pubDate>Fri, 16 Oct 2015 15:04:23 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/10/php-array-merge/</guid>
      <description>&lt;p&gt;这个例子比较全面的比较了PHP合并两个数组常见的方法array_merge和+的区别：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$array1 = array(
    &amp;lsquo;test1&amp;rsquo; =&amp;gt; &amp;lsquo;test1&amp;rsquo;,
    &amp;lsquo;test2&amp;rsquo; =&amp;gt; &amp;lsquo;test2&amp;rsquo;,
    8       =&amp;gt; &amp;lsquo;9&amp;rsquo;,
    &amp;lsquo;10&amp;rsquo;    =&amp;gt; &amp;lsquo;1010&amp;rsquo;,
    &amp;lsquo;s10&amp;rsquo;   =&amp;gt; &amp;lsquo;s10&amp;rsquo;,
);&lt;/p&gt;

&lt;p&gt;$array2 = array(
    &amp;lsquo;test1&amp;rsquo; =&amp;gt; &amp;lsquo;test1+&amp;rsquo;,
    &amp;lsquo;test2&amp;rsquo; =&amp;gt; &amp;lsquo;test2+&amp;rsquo;,
    &amp;lsquo;++&amp;rsquo;    =&amp;gt; &amp;lsquo;++&amp;rsquo;,
    8       =&amp;gt; &amp;lsquo;9999&amp;rsquo;,
    &amp;lsquo;10&amp;rsquo;    =&amp;gt; &amp;lsquo;10101010&amp;rsquo;,
    &amp;lsquo;s10&amp;rsquo;   =&amp;gt; &amp;lsquo;s10101010&amp;rsquo;,
);&lt;/p&gt;

&lt;p&gt;$result = array_merge($array1,$array2);
$result2 = $array1+$array2;
var_dump($result);
var_dump($result2);
exit;&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mac下firefox插件hostadmin切换host权限不足</title>
      <link>http://tanteng.me/2015/09/mac-firefox-hostadmin/</link>
      <pubDate>Fri, 04 Sep 2015 16:58:14 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/09/mac-firefox-hostadmin/</guid>
      <description>在Mac下firefox插件hostadmin切换host时提示权限不足，解决办法，在终端输入以下命令即可：
sudo chmod og+w /etc/hosts
chmod修改权限，og+w表示增加写权限。</description>
    </item>
    
    <item>
      <title>PHP变量名区分大小写，函数和方法名不区分大小写</title>
      <link>http://tanteng.me/2015/09/php-lower-diff/</link>
      <pubDate>Fri, 04 Sep 2015 01:35:02 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/09/php-lower-diff/</guid>
      <description>PHP变量名区分大小写，函数和方法名不区分大小写</description>
    </item>
    
    <item>
      <title>PHP浮点数运算精度的问题</title>
      <link>http://tanteng.me/2015/08/php-float/</link>
      <pubDate>Wed, 12 Aug 2015 06:24:28 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/08/php-float/</guid>
      <description>&lt;p&gt;在用PHP进行浮点数的运算中，遇到一个坑，没有得到预期中的结果，如下代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$a = 69.1;&lt;/p&gt;

&lt;p&gt;$b = $a*100;&lt;/p&gt;

&lt;p&gt;$c = $b-6910;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;你猜$c的值是多少？$c输出的值是-9.0949470177293E-13.为什么会这样？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用vagrant安装VirtualBox虚拟机说明</title>
      <link>http://tanteng.me/2015/08/virtualbox-vagrant/</link>
      <pubDate>Tue, 11 Aug 2015 08:53:12 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/08/virtualbox-vagrant/</guid>
      <description>&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-8553&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2015/08/111.png&#34; alt=&#34;111&#34; width=&#34;96&#34; height=&#34;173&#34; /&gt;&lt;/p&gt;

&lt;p&gt;首先安装这个玩意VirtualBox~~&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-8554&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2015/08/222.png&#34; alt=&#34;222&#34; width=&#34;98&#34; height=&#34;131&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后安装这个玩意vagrant&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP匿名函数的实例</title>
      <link>http://tanteng.me/2015/08/php-closure-demo/</link>
      <pubDate>Tue, 11 Aug 2015 08:35:47 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/08/php-closure-demo/</guid>
      <description>PHP5.3起就支持匿名函数，可以放心在生产环境中使用，对于PHP的很多新特性该用的地方要大胆使用，可以使代码更简洁，功能实现也更加方便。
以下是PHP匿名函数的一个小的简单实例：
function func($list,$u_wangwang) { //匿名函数，获取其他行联号 $other_num = function($num){ $num = explode(&amp;lsquo;.&amp;rsquo;, $num); return $num[0]; }; $res = $other_num($v[&amp;lsquo;sb_other_num&amp;rsquo;]); return $res; }
首先在方法里定义了一个匿名函数，有一个参数，然后调用的时候进行传参。</description>
    </item>
    
    <item>
      <title>使用Redis防止重复提交</title>
      <link>http://tanteng.me/2015/08/redis-lock/</link>
      <pubDate>Tue, 11 Aug 2015 08:21:10 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/08/redis-lock/</guid>
      <description>&lt;p&gt;使用Redis可以很方便的防止表单或者按钮重复提交，给动作加锁，在一定时间内不能再次执行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;//防止重复提交
$lock&lt;em&gt;nopay = &amp;lsquo;nopay&lt;/em&gt;&amp;rsquo;.$sb_id.$sb_uid.$pay_money;
if(!$this-&amp;gt;lock(10,$lock_nopay)){
    $this-&amp;gt;error(&amp;ldquo;当前取消打款操作尚未完成，请勿重复操作！&amp;rdquo;);
}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里调用lock方法，锁定10秒钟，10秒钟内如果再次提交就中断操作，认为是重复提交。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP队列服务HTTPSQS的安装和使用</title>
      <link>http://tanteng.me/2015/08/php-httpsqs/</link>
      <pubDate>Tue, 11 Aug 2015 05:38:27 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/08/php-httpsqs/</guid>
      <description>&lt;p&gt;HTTPSQS(HTTP Simple Queue Service)是一个基于HTTP GET/POST请求的简单队列服务。&lt;figure id=&#34;attachment_8542&#34; style=&#34;width: 500px&#34; class=&#34;wp-caption alignnone&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.tanteng.me/wp-content/uploads/2015/08/httpsqs_elements.png&#34; target=&#34;_blank&#34;&gt;&lt;img class=&#34;wp-image-8542 size-full&#34; src=&#34;https://blog.tanteng.me/wp-content/uploads/2015/08/httpsqs_elements.png&#34; alt=&#34;PHP队列服务HTTPSQS的安装和使用&#34; width=&#34;500&#34; height=&#34;503&#34; srcset=&#34;https://blog.tanteng.me/wp-content/uploads/2015/08/httpsqs_elements.png 500w, https://blog.tanteng.me/wp-content/uploads/2015/08/httpsqs_elements-150x150.png 150w, https://blog.tanteng.me/wp-content/uploads/2015/08/httpsqs_elements-298x300.png 298w&#34; sizes=&#34;(max-width: 500px) 100vw, 500px&#34; /&gt;&lt;/a&gt;&lt;figcaption class=&#34;wp-caption-text&#34;&gt;PHP队列原理图&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用mod_concatx扩展合并js,css</title>
      <link>http://tanteng.me/2015/08/mod-concat-js-css/</link>
      <pubDate>Tue, 11 Aug 2015 01:39:04 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/08/mod-concat-js-css/</guid>
      <description>&lt;p&gt;PHP的mod_concatx模块扩展可以方便的把多个js，css文件合并成一个文件，以加速页面的渲染，减少请求时间和服务器压力。mod_concatx模块是在mod_concat基础上修改的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:xhtml decode:true &#34;&gt;&amp;lt;link rel=&amp;ldquo;stylesheet&amp;rdquo; type=&amp;ldquo;text/css&amp;rdquo; media=&amp;ldquo;screen&amp;rdquo; ←
    href=&amp;ldquo;&lt;a href=&#34;http://lemon.holsman.net:8001/cdn/??music2.css,common.css&amp;quot;&#34;&gt;http://lemon.holsman.net:8001/cdn/??music2.css,common.css&amp;quot;&lt;/a&gt; /&amp;gt;
&amp;lt;script type=&amp;ldquo;text/javascript&amp;rdquo;  ←
    src=&amp;ldquo;&lt;a href=&#34;http://lemon.holsman.net:8001/cdn/??music2.js,mp.js,dalai_llama.js,ratings_widget.js,widget_config.js,common.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#34;&gt;http://lemon.holsman.net:8001/cdn/??music2.js,mp.js,dalai_llama.js,ratings_widget.js,widget_config.js,common.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/a&gt;
&amp;lt;script language=&amp;ldquo;javascript&amp;rdquo; type=&amp;ldquo;text/javascript&amp;rdquo; ←
    src=&amp;ldquo;&lt;a href=&#34;http://tangerine.holsman.net:8001/o/??journals_blog_this.js,adsWrapper.js,flashtag.js,feeds_subscribe.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#34;&gt;http://tangerine.holsman.net:8001/o/??journals_blog_this.js,adsWrapper.js,flashtag.js,feeds_subscribe.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/a&gt;
&amp;lt;script type=&amp;ldquo;text/javascript&amp;rdquo;  ←
    src=&amp;ldquo;&lt;a href=&#34;http://orange.holsman.net:8001/digital/??dm_client_aol.js,cannae.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#34;&gt;http://orange.holsman.net:8001/digital/??dm_client_aol.js,cannae.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP5.5的迭代生成器</title>
      <link>http://tanteng.me/2015/08/php-yield/</link>
      <pubDate>Sat, 08 Aug 2015 16:12:17 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/08/php-yield/</guid>
      <description>&lt;p&gt;PHP5.5引入了迭代生成器的概念，迭代的概念早就在PHP有了，但是迭代生成器是PHP的一个新特性，这跟python3中的迭代生成器类似，看看PHP5.5的迭代生成器如何定义。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;&amp;lt;?php
    function xrange($start, $end, $step = 1) {
        for ($i = $start; $i &amp;lt;= $end; $i += $step) {
            yield $i;
        }
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach (xrange(1, 1000000) as $num) {
    echo $num, &amp;quot;\n&amp;quot;;
}&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>PHP5.6 curl去除@语法</title>
      <link>http://tanteng.me/2015/08/php5-6-curl/</link>
      <pubDate>Tue, 04 Aug 2015 10:24:53 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/08/php5-6-curl/</guid>
      <description>&lt;p&gt;在一个传图方法中用到了curl上传文件，在文件名前加上@语法表示上传文件，这在PHP5.3中是正常的，但是在PHP5.6中彻底废除了@语法，导致上传图片无法使用。&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php mark:5 decode:true &#34;&gt;//支持远程文件上传
if(empty($urlinfo[&amp;lsquo;host&amp;rsquo;])){
    $tmp_name=dirname($file[&amp;lsquo;tmp_name&amp;rsquo;]).&amp;lsquo;/&amp;rsquo;.$file[&amp;lsquo;title&amp;rsquo;].&amp;lsquo;.&amp;rsquo;.$file[&amp;lsquo;extension&amp;rsquo;];//加上文件后缀
    rename($file[&amp;lsquo;tmp_name&amp;rsquo;],$tmp_name);
    $fields[&amp;lsquo;file&amp;rsquo;] = &amp;lsquo;@&amp;rsquo;.$tmp_name;//加@符号curl就会把它当成是文件上传处理
}else{
    $fields[&amp;lsquo;url&amp;rsquo;]=$file[&amp;lsquo;tmp_name&amp;rsquo;];
}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP在shell里面换行使用PHP_EOL</title>
      <link>http://tanteng.me/2015/08/php-shell-php_eol/</link>
      <pubDate>Sat, 01 Aug 2015 06:34:05 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/08/php-shell-php_eol/</guid>
      <description>&lt;p&gt;PHP在shell里面换行使用PHP_EOL，shell不认识&lt;br&gt;&lt;br/&gt;之类的html标记。或者使用PHP_EOL (string)常量，可以取得运行系统中换行符。linux中是\n, win中是\r\n, mac中是\r.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在SAE执行PHP计划任务</title>
      <link>http://tanteng.me/2015/07/sae-cron/</link>
      <pubDate>Thu, 23 Jul 2015 01:30:56 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/07/sae-cron/</guid>
      <description>&lt;p&gt;在SAE中运行PHP计划任务，是编辑APPNAME/1/config.yaml文件(APPNAME是你的应用名，1代表版本号)，输入cron作业的描述。&lt;/p&gt;

&lt;p&gt;目前SAE平台支持使用类自然语言或者unix crontab语言描述cron任务。&lt;/p&gt;

&lt;p&gt;本页有两个示例代码，将下面的任意一种config.yaml保存后，放置于应用目录中即可。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PhpStorm 9.0注册码（License Key）</title>
      <link>http://tanteng.me/2015/07/phpstorm-9-0%E6%B3%A8%E5%86%8C%E7%A0%81license-key/</link>
      <pubDate>Fri, 17 Jul 2015 15:38:31 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/07/phpstorm-9-0%E6%B3%A8%E5%86%8C%E7%A0%81license-key/</guid>
      <description>&lt;p&gt;PhpStorm注册码&lt;/p&gt;

&lt;p&gt;User Name:&lt;/p&gt;

&lt;p&gt;EMBRACE&lt;/p&gt;

&lt;p&gt;License Key:&lt;/p&gt;

&lt;p&gt;===== LICENSE BEGIN =====&lt;/p&gt;

&lt;p&gt;43136-12042010&lt;/p&gt;

&lt;p&gt;00002UsvSON704l&amp;#8221;dILe1PVx3y4&amp;#8243;B3&lt;/p&gt;

&lt;p&gt;49AU6oSDJrsjE8nMOQh&amp;#8221;8HTDJHIUUh&lt;/p&gt;

&lt;p&gt;gd1BebYc5U&amp;#8221;6OxDbVsALB4Eb10PW8&amp;#8243;&lt;/p&gt;

&lt;p&gt;===== LICENSE END =====&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP return 的其他用法</title>
      <link>http://tanteng.me/2015/07/php-return/</link>
      <pubDate>Wed, 08 Jul 2015 15:22:02 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/07/php-return/</guid>
      <description>&lt;p&gt;PHP 的 return 的含义大家很清楚了，几乎随处可见，但是见过在函数外使用 return 的吗？如下代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;require_once(&amp;lsquo;./bb-load.php&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;bb_repermalink(); // The magic happens here.&lt;/p&gt;

&lt;p&gt;if ($self) {
    if (strpos($self, &amp;lsquo;.php&amp;rsquo;) !== false) {
        require($self);
    } else {
        require(BB_PATH . &amp;lsquo;profile-base.php&amp;rsquo;);
    }
    return;
}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>防止表单重复提交的方式</title>
      <link>http://tanteng.me/2015/07/form-submit/</link>
      <pubDate>Wed, 08 Jul 2015 15:12:14 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/07/form-submit/</guid>
      <description>&lt;p&gt;关于防止表单重复提交的做法有很多，本人知道的有如下，简单讲讲几种方式。有redis，session，jquery等几种方法。&lt;/p&gt;

&lt;p&gt;1.有redis的环境&lt;/p&gt;

&lt;p&gt;把提交的动作action，参数之类的作为redis的key，存进redis，设置一个很短的缓存时间，提交的时候判断如果存在这个key，说明是重复提交数据。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP连接mongodb认证错误:Failed to connect,Authentication failed</title>
      <link>http://tanteng.me/2015/07/authentication-failed/</link>
      <pubDate>Wed, 08 Jul 2015 06:40:56 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/07/authentication-failed/</guid>
      <description>&lt;p&gt;PHP扩展php_mongo.dll无法通过用户名密码认证的方式连接mongodb数据库，报错如下：&lt;strong&gt;Fatal error&lt;/strong&gt;: Uncaught exception &amp;#8216;MongoConnectionException&amp;#8217; with message &amp;#8216;Failed to connect to: 127.0.0.1:27017: Authentication failed on database &amp;#8216;js_send_excel&amp;#8217; with username &amp;#8216;tanteng22&amp;#8242;: auth failed&amp;#8217; in D:\xampp\htdocs\v3\index.php:6 Stack trace: #0 D:\xampp\htdocs\v3\index.php(6): MongoClient-&amp;gt;__construct(&amp;#8216;mongodb://tante&amp;#8230;&amp;#8217;) #1 {main} thrown in &lt;strong&gt;D:\xampp\htdocs\v3\index.php&lt;/strong&gt; on line &lt;strong&gt;6&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用array_map()和array_reduce()替代foreach循环</title>
      <link>http://tanteng.me/2015/07/array-map-reduce-foreach/</link>
      <pubDate>Fri, 03 Jul 2015 08:26:56 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/07/array-map-reduce-foreach/</guid>
      <description>&lt;p&gt;有时候不一定非得使用foreach，有更好的PHP内置数组函数处理数组，如使用array_map()和array_reduce()替代foreach循环。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>理解PHP array_reduce函数</title>
      <link>http://tanteng.me/2015/07/php-array-reduce/</link>
      <pubDate>Fri, 03 Jul 2015 03:28:26 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/07/php-array-reduce/</guid>
      <description>&lt;p&gt;PHP的array_reduce函数作用是（官方定义）：array_reduce() 将回调函数 function 迭代地作用到 input 数组中的每一个单元中，从而将数组简化为单一的值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ThinkPHP扩展MongoDB Model支持getGridFS存取文件</title>
      <link>http://tanteng.me/2015/06/thinkphp-mongodb-getgridfs/</link>
      <pubDate>Fri, 19 Jun 2015 09:44:09 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/06/thinkphp-mongodb-getgridfs/</guid>
      <description>&lt;p&gt;ThinkPHP自带MongoDB Model，Model继承MongoDBModel可以操作MongoDB数据库，但只能操作基本的一些MongoDB操作，无法操作getGridFS存取文件，需要扩展Driver/Db/DbMongo.class.php文件。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP操作GridFS存储文件到MongoDB的三种方式</title>
      <link>http://tanteng.me/2015/06/php-mongodb-gridfs/</link>
      <pubDate>Thu, 18 Jun 2015 08:47:59 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/06/php-mongodb-gridfs/</guid>
      <description>一般情况采取第一种方法，直接传文件，第二种方法适合生成的数据不用保存到本地再上传而是直接以二进制存到MongoDB，第三种方式是直接把表单上传的文件存进MongoDB.
//初始化gridfs $conn = new Mongo(); //连接MongoDB $db = $conn-&amp;gt;photos; //选择数据库 $grid = $db-&amp;gt;getGridFS(); //取得gridfs对象
//gridfs有三种方式存储文件 //第一种直接存储文件 $id = $grid-&amp;gt;storeFile(&amp;ldquo;./logo.png&amp;rdquo;);
//第二种存储文件二进制流 $data = get_file_contents(&amp;ldquo;./logo.png&amp;rdquo;); $id = $grid-&amp;gt;storeBytes($data,array(&amp;ldquo;parame&amp;rdquo;=&amp;gt;’附加参数将随图片一起存入’));
//第三种保存直接表单提交的文件$_FILES $id = $grid-&amp;gt;storeUpload(&amp;lsquo;upfile&amp;rsquo;); //相当于 $id = $grid-&amp;gt;storeFile($_FILES[‘upfile’][‘tmp_name’]);
//&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;以上是保存图片&amp;ndash;下面开始读取图片&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-
//保存成功后返回$id = md5字符串 $logo = $grid-&amp;gt;findOne(array(&amp;rsquo;_id&amp;rsquo;=&amp;gt;new MongoId($id))); //以_id为索引取得文件 header(&amp;lsquo;Content-type: image/png&amp;rsquo;); //输出图片头 echo $logo -&amp;gt;getBytes(); //输出数据流
注意：在使用$grid-&amp;gt;finOne的时候，_id的值应该是MongoDB的ObjectId类型。</description>
    </item>
    
    <item>
      <title>MongoDB GridFS存取文件PHP示例</title>
      <link>http://tanteng.me/2015/06/mongodb-gridfs-php/</link>
      <pubDate>Thu, 18 Jun 2015 03:20:51 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/06/mongodb-gridfs-php/</guid>
      <description>&lt;p&gt;最近项目需要用到MongoDB存取文件，这里有个简单的PHP示例：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;public function run(){
    //初始化gridfs
    $m = new MongoClient(); // 连接
    $db = $m-&amp;gt;selectDB(&amp;ldquo;excel&amp;rdquo;);
    //dump($m);exit;
    //$collection = $db-&amp;gt;testexcel;
    $grid = $db-&amp;gt;getGridFS(); //取得gridfs对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//gridfs有三种方式存储文件
//第一种直接存储文件
$id = $grid-&amp;amp;gt;storeFile(dirname(__FILE__).&amp;quot;/EmptyAction.class.php&amp;quot;);
echo $id;

//获取文件
$file = $grid-&amp;amp;gt;findOne(array(&#39;_id&#39;=&amp;amp;gt;$id)); //以_id为索引取得文件 
//header(&#39;Content-type: image/png&#39;); //输出图片头 
dump($file);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>深入理解Yii2</title>
      <link>http://tanteng.me/2015/06/yii2-digpage/</link>
      <pubDate>Fri, 05 Jun 2015 15:54:34 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/06/yii2-digpage/</guid>
      <description>推荐一个网站：
http://www.digpage.com/index.html</description>
    </item>
    
    <item>
      <title>array_unshift,array_shift及array_pop,array_push的定义</title>
      <link>http://tanteng.me/2015/06/array-unshift-shift-pop-push/</link>
      <pubDate>Thu, 04 Jun 2015 15:48:22 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/06/array-unshift-shift-pop-push/</guid>
      <description>array_unshift,array_shift,array_pop,array_push这几个函数容易混淆，其实概念很简单，定义如下：
array_unshift:在数组开头插入元素
array_shift:在数组开头移除元素
array_pop:出栈，也就是在数组末尾移除元素
array_push:入栈，把元素加到数组末尾
使用这几个函数可以实现PHP双向队列，如：
class DoubleEndedQueue{
protected $elements;
public function __construct(){
$this-&amp;gt;elements = array();
}
public function push($element){
array_unshift($this-&amp;gt;elements , $element);
}
public function pop(){
return array_shift($this-&amp;gt;element);
}
public function inject($element){
$this-&amp;gt;elements[] = $element;
}
public function eject(){
array_pop($this-&amp;gt;elements);
}
}
?&amp;gt;</description>
    </item>
    
    <item>
      <title>WordPress标签云和列表移除指定ID不显示</title>
      <link>http://tanteng.me/2015/06/cat-tag-exclude/</link>
      <pubDate>Thu, 04 Jun 2015 05:04:36 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/06/cat-tag-exclude/</guid>
      <description>&lt;p&gt;WordPress的标签页和列表挂件，如果想把某些标签或列表不予显示，可以使用如下两个钩子方法实现，具体代码如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;//移除部分标签不在标签云显示
function remove_tags($args){
    $new_args = array(
            &amp;lsquo;exclude&amp;rsquo; =&amp;gt; &amp;lsquo;30,40,128,131,83&amp;rsquo;,
        );
    return array_merge($args,$new_args);
}
add_filter( &amp;lsquo;widget_tag_cloud_args&amp;rsquo;, &amp;lsquo;remove_tags&amp;rsquo; );&lt;/p&gt;

&lt;p&gt;//移除部分标签不在列表widget显示
function exclude_widget_categories($args){
    $exclude = &amp;ldquo;4,6,12,88,172&amp;rdquo;; // The IDs of the excluding categories
    $args[&amp;ldquo;exclude&amp;rdquo;] = $exclude;
    return $args;
}
add_filter(&amp;ldquo;widget_categories_args&amp;rdquo;,&amp;ldquo;exclude_widget_categories&amp;rdquo;);&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP匿名函数</title>
      <link>http://tanteng.me/2015/06/php-anonymous-function/</link>
      <pubDate>Mon, 01 Jun 2015 09:00:12 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/06/php-anonymous-function/</guid>
      <description>&lt;p&gt;PHP5.3以来也出现了很多新的特性：&lt;/p&gt;

&lt;p&gt;PHP5.2 以前：autoload, PDO 和 MySQLi, 类型约束&lt;/p&gt;

&lt;p&gt;PHP5.2：JSON 支持&lt;/p&gt;

&lt;p&gt;PHP5.3：弃用的功能，匿名函数，新增魔术方法，命名空间，后期静态绑定，Heredoc 和 Nowdoc, const, 三元运算符，Phar&lt;/p&gt;

&lt;p&gt;PHP5.4：Short Open Tag, 数组简写形式，Traits, 内置 Web 服务器，细节修改&lt;/p&gt;

&lt;p&gt;PHP5.5：yield, list() 用于 foreach, 细节修改&lt;/p&gt;

&lt;p&gt;PHP5.6: 常量增强，可变函数参数，命名空间增强&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>修改bash_profile文件切换Mac默认PHP版本为MAMP</title>
      <link>http://tanteng.me/2015/05/bash_profile-mac-php/</link>
      <pubDate>Sat, 30 May 2015 15:42:46 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/05/bash_profile-mac-php/</guid>
      <description>&lt;p&gt;Mac自带了PHP开发环境，但是很多开发者装了MAMP集成环境，打开终端输入：which php，会显示/usr/bin/php，是系统自带的PHP版本，要切换默认的PHP版本为MAMP下的PHP，需要修改系统bash_profile并执行这个shell脚本。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>初识PHP Static延迟静态绑定</title>
      <link>http://tanteng.me/2015/05/php-static-bind/</link>
      <pubDate>Wed, 27 May 2015 03:38:42 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/05/php-static-bind/</guid>
      <description>&lt;p&gt;PHP5.3以后引入了延迟静态绑定static，它是为了解决什么问题呢？php的继承模型中有一个存在已久的问题，那就是在父类中引用扩展类的最终状态比较困难。来看一个例子。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;class A&lt;br /&gt;
{&lt;br /&gt;
    public static function echoClass(){&lt;br /&gt;
        echo &lt;strong&gt;CLASS&lt;/strong&gt;;&lt;br /&gt;
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static function test(){  
    self::echoClass();        
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;class B extends A&lt;br /&gt;
{&lt;br /&gt;
    public static function echoClass()&lt;br /&gt;
    {&lt;br /&gt;
         echo &lt;strong&gt;CLASS&lt;/strong&gt;;&lt;br /&gt;
    }&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;B::test(); //输出A&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP 开发者该知道的 5 个 Composer 小技巧</title>
      <link>http://tanteng.me/2015/05/php-composer/</link>
      <pubDate>Tue, 26 May 2015 03:49:35 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/05/php-composer/</guid>
      <description>Composer是新一代的PHP依赖管理工具。其介绍和基本用法可以看这篇《Composer PHP依赖管理的新时代》。本文介绍使用Composer的五个小技巧，希望能给你的PHP开发带来方便。
PHP 开发者该知道的 5 个 Composer 小技巧：
http://segmentfault.com/a/1190000000355928</description>
    </item>
    
    <item>
      <title>REST模式GET，POST，PUT，DELETE</title>
      <link>http://tanteng.me/2015/05/rest-get-post-put-delete/</link>
      <pubDate>Sat, 23 May 2015 15:35:02 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/05/rest-get-post-put-delete/</guid>
      <description>&lt;p&gt;HTTP常见的请求方式我们熟知的有GET和POST，这两个很好理解，但是在Rest中跟我们平常的理解又有所不同，本文重点介绍一下Rest模式这几种方式的概念，以及它们的使用场景。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DIRECTORY_SEPARATOR 和 PATH_SEPARATOR的区别</title>
      <link>http://tanteng.me/2015/05/directory-path-separator/</link>
      <pubDate>Thu, 21 May 2015 10:25:40 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/05/directory-path-separator/</guid>
      <description>&lt;p&gt;DIRECTORY_SEPARATOR：目录分隔符，linux上就是&amp;#8217;/&amp;#8217;,windows上是&amp;#8217;&amp;amp;#8217;.&lt;/p&gt;

&lt;p&gt;PATH_SEPARATOR：路径分隔符，include多个路径使用，在win下，当你要include多个路径的话，你要用&amp;#8221;;&amp;#8221;隔开，但在linux下就使用&amp;#8221;:&amp;#8221;隔开的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>left join多张表查出重复数据的解决办法</title>
      <link>http://tanteng.me/2015/05/left-join-duplication/</link>
      <pubDate>Tue, 19 May 2015 08:53:04 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/05/left-join-duplication/</guid>
      <description>&lt;p&gt;今天线上出现一个问题，查询售后订单出现很多重复的内容，经查，是left join多张表导致的查询出重复数据。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Redis如何存取PHP多维数组</title>
      <link>http://tanteng.me/2015/04/redis-php-array/</link>
      <pubDate>Tue, 21 Apr 2015 03:09:45 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/04/redis-php-array/</guid>
      <description>&lt;p&gt;Redis本身不支持存取PHP数组的数据结构，但是如何存取PHP的数组呢？可以把数组序列化，以字符串的形式缓存到Redis中。&lt;/p&gt;

&lt;p&gt;其实很多框架或封装好的Redis类中，都做好了自动转化，直接存数据就可以了。如代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public function testSavePHPArray() {
    $array = [&amp;lsquo;array1&amp;rsquo;,&amp;lsquo;array2&amp;rsquo;,[&amp;lsquo;array3key&amp;rsquo;=&amp;gt;&amp;lsquo;array3value&amp;rsquo;]];
    $redis = RedisHandle::getInstance();
    $redis-&amp;gt;set(&amp;lsquo;save_php_array_test&amp;rsquo;,$array);
}&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>什么时候使用mysql事务？</title>
      <link>http://tanteng.me/2015/04/mysql-commit/</link>
      <pubDate>Tue, 07 Apr 2015 15:25:18 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/04/mysql-commit/</guid>
      <description>&lt;p&gt;突然想到一个问题，mysql中我们经常用到事务，比如一次向几张表插入内容，如果中间出错了可以回滚，但是实际开发中，像这种一次可能向多个数据表写入数据的情况，并没有采用事务。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP接口开发加密技术</title>
      <link>http://tanteng.me/2015/03/php-api-token/</link>
      <pubDate>Tue, 03 Mar 2015 11:57:13 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/03/php-api-token/</guid>
      <description>&lt;p&gt;PHP接口开发是PHP常见的技术，可以通过接口进行一些操作，可以访问接口获取数据，给app提供数据接口等，但是如果接口没有加密解密的过程，很容易发生盗用和不安全的操作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>也谈PHP中$GLOBALS和global的区别</title>
      <link>http://tanteng.me/2015/01/php-globals-global-difference/</link>
      <pubDate>Sat, 31 Jan 2015 02:28:47 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/01/php-globals-global-difference/</guid>
      <description>&lt;p&gt;在PHP中经常遇到$GLOBALS和global来定义和访问全局变量，那么在什么地方该用$GLOBALS，而什么地方该用global呢？这就需要我们清除了解$GLOBALS和global的区别，我也谈谈PHP中$GLOBALS和global的不同，要真正弄懂它们的区别和共同点请仔细看这篇文章。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>什么时候用require_once，什么时候用include</title>
      <link>http://tanteng.me/2015/01/require-once-include/</link>
      <pubDate>Fri, 16 Jan 2015 02:15:57 +0000</pubDate>
      
      <guid>http://tanteng.me/2015/01/require-once-include/</guid>
      <description>&lt;p&gt;我们知道PHP中引入文件有几种方式，比如require_once和include，它们的区别很多文章都讲过了，那么具体在什么时候用require_once，什么时候用include呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP xml转换json</title>
      <link>http://tanteng.me/2014/12/php-xml2json/</link>
      <pubDate>Thu, 11 Dec 2014 02:46:44 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/12/php-xml2json/</guid>
      <description>&lt;p&gt;PHP xml转换json很简单，使用自带的xml类simplexml_load_file方法读取xml文件，再用json_encode函数直接把xml转换json格式。代码示例：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>extension_loaded检测扩展是否开启</title>
      <link>http://tanteng.me/2014/12/extension-loaded-json/</link>
      <pubDate>Tue, 09 Dec 2014 07:34:36 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/12/extension-loaded-json/</guid>
      <description>&lt;p&gt;PHP extension_loaded函数用于检测扩展有没有开启，常见的PHP扩展有curl，json，之所以用extension_loaded检测扩展是否开启，是因为兼容性的需要，开发的程序或插件在有的环境中可能没开启相应的扩展，就要判断一下是否采用其他方案。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>EUC-CN是什么编码</title>
      <link>http://tanteng.me/2014/12/euc-cn/</link>
      <pubDate>Mon, 01 Dec 2014 10:21:27 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/12/euc-cn/</guid>
      <description>&lt;p&gt;PHP开发使用mb_detect_encoding函数可以检测字符串是什么编码，检测到字符串编码为EUC-CN，EUC-CN是什么编码？&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php range:1 decode:true &#34; title=&#34;mb_detect_encoding&#34;&gt;echo mb_detect_encoding($_GET[&amp;lsquo;tag&amp;rsquo;],array(&amp;ldquo;ASCII&amp;rdquo;,&amp;ldquo;UTF-8&amp;rdquo;,&amp;ldquo;GB2312&amp;rdquo;,&amp;ldquo;GBK&amp;rdquo;,&amp;ldquo;BIG5&amp;rdquo;));
exit;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;mb_detect_encoding检测编码函数用法，需要两个参数，第一个参数是要检测的字符串，第二个参数是一个数组，包含要检测的编码类型。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP定义二维数组静态变量类型</title>
      <link>http://tanteng.me/2014/12/php-array-static/</link>
      <pubDate>Mon, 01 Dec 2014 06:18:50 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/12/php-array-static/</guid>
      <description>&lt;p&gt;PHP定义静态变量类型就是在变量前加上关键字static，如static $string=&amp;#8221;,static $array=array();但是如何给二维数组定义静态变量类型，如static $array[&amp;#8216;abc&amp;#8217;]=array()这样定义行吗？&lt;/p&gt;

&lt;p&gt;这样定义PHP二维数组静态类型是错的，比如要定义$array[&amp;#8216;abc&amp;#8217;]为静态变量，只需给$array定义成静态变量，如static $array=array().&lt;/p&gt;

&lt;p&gt;定义静态变量是针对这个变量的，一个数组就是一个变量，无论它是一位数组还是二维数组，不存在定义数组下面的元素为静态变量，只有这个变量本身是什么类型。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP xss安全过滤函数</title>
      <link>http://tanteng.me/2014/12/php-xss/</link>
      <pubDate>Mon, 01 Dec 2014 02:21:53 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/12/php-xss/</guid>
      <description>PHP xss安全过滤函数
/** * xss过滤函数 * * @param $string * @return string */ function remove_xss($string) { $string = preg_replace(&amp;lsquo;/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]+/S&amp;rsquo;, &amp;ldquo;, $string);
$parm1 = Array(&#39;javascript&#39;, &#39;vbscript&#39;, &#39;expression&#39;, &#39;applet&#39;, &#39;meta&#39;, &#39;xml&#39;, &#39;blink&#39;, &#39;link&#39;, &#39;script&#39;, &#39;embed&#39;, &#39;object&#39;, &#39;iframe&#39;, &#39;frame&#39;, &#39;frameset&#39;, &#39;ilayer&#39;, &#39;layer&#39;, &#39;bgsound&#39;, &#39;title&#39;, &#39;base&#39;); $parm2 = Array(&#39;onabort&#39;, &#39;onactivate&#39;, &#39;onafterprint&#39;, &#39;onafterupdate&#39;, &#39;onbeforeactivate&#39;, &#39;onbeforecopy&#39;, &#39;onbeforecut&#39;, &#39;onbeforedeactivate&#39;, &#39;onbeforeeditfocus&#39;, &#39;onbeforepaste&#39;, &#39;onbeforeprint&#39;, &#39;onbeforeunload&#39;, &#39;onbeforeupdate&#39;, &#39;onblur&#39;, &#39;onbounce&#39;, &#39;oncellchange&#39;, &#39;onchange&#39;, &#39;onclick&#39;, &#39;oncontextmenu&#39;, &#39;oncontrolselect&#39;, &#39;oncopy&#39;, &#39;oncut&#39;, &#39;ondataavailable&#39;, &#39;ondatasetchanged&#39;, &#39;ondatasetcomplete&#39;, &#39;ondblclick&#39;, &#39;ondeactivate&#39;, &#39;ondrag&#39;, &#39;ondragend&#39;, &#39;ondragenter&#39;, &#39;ondragleave&#39;, &#39;ondragover&#39;, &#39;ondragstart&#39;, &#39;ondrop&#39;, &#39;onerror&#39;, &#39;onerrorupdate&#39;, &#39;onfilterchange&#39;, &#39;onfinish&#39;, &#39;onfocus&#39;, &#39;onfocusin&#39;, &#39;onfocusout&#39;, &#39;onhelp&#39;, &#39;onkeydown&#39;, &#39;onkeypress&#39;, &#39;onkeyup&#39;, &#39;onlayoutcomplete&#39;, &#39;onload&#39;, &#39;onlosecapture&#39;, &#39;onmousedown&#39;, &#39;onmouseenter&#39;, &#39;onmouseleave&#39;, &#39;onmousemove&#39;, &#39;onmouseout&#39;, &#39;onmouseover&#39;, &#39;onmouseup&#39;, &#39;onmousewheel&#39;, &#39;onmove&#39;, &#39;onmoveend&#39;, &#39;onmovestart&#39;, &#39;onpaste&#39;, &#39;onpropertychange&#39;, &#39;onreadystatechange&#39;, &#39;onreset&#39;, &#39;onresize&#39;, &#39;onresizeend&#39;, &#39;onresizestart&#39;, &#39;onrowenter&#39;, &#39;onrowexit&#39;, &#39;onrowsdelete&#39;, &#39;onrowsinserted&#39;, &#39;onscroll&#39;, &#39;onselect&#39;, &#39;onselectionchange&#39;, &#39;onselectstart&#39;, &#39;onstart&#39;, &#39;onstop&#39;, &#39;onsubmit&#39;, &#39;onunload&#39;); $parm = array_merge($parm1, $parm2); for ($i = 0; $i &amp;amp;lt; sizeof($parm); $i++) { $pattern = &#39;/&#39;; for ($j = 0; $j &amp;amp;lt; strlen($parm[$i]); $j++) { if ($j &amp;gt; 0) { $pattern .</description>
    </item>
    
    <item>
      <title>preg_match过滤URL非法参数</title>
      <link>http://tanteng.me/2014/11/preg_match_illegal_parameters/</link>
      <pubDate>Wed, 26 Nov 2014 04:01:40 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/11/preg_match_illegal_parameters/</guid>
      <description>&lt;p&gt;PHP开发中经常用到URL传递参数，对传递的参数要进行安全过滤，过滤URL中非法参数，这是php安全的一个细小的地方，却事关安全的大事。URL参数一般都是数字或者字母加上&amp;#8221;-&amp;#8220;或者&amp;#8221;_&amp;#8221;组成，参数带有其他的符号的都要进行过滤，以免带来安全问题。对URL传参进行非法字符过滤，用preg_match很容易判断非法的参数。&lt;/p&gt;

&lt;p&gt;&lt;code lang=&#34;php&#34;&gt;if(!preg&lt;em&gt;match(&amp;ldquo;/^[a-z0-9&lt;/em&gt;-]+$/i&amp;rdquo;,$this-&amp;gt;commentid))
    $this-&amp;gt;_show_msg(L(&amp;lsquo;illegal_parameters&amp;rsquo;));
&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sublime必备插件for PHP</title>
      <link>http://tanteng.me/2014/11/sublime-plugin-php/</link>
      <pubDate>Sat, 22 Nov 2014 08:19:23 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/11/sublime-plugin-php/</guid>
      <description>&lt;p&gt;Sublime Text真是一款写代码的利器，轻巧快捷，而且功能强大，用来写PHP代码再好不过了，告别以前用的笨重臃肿的Zend Studio，感觉一身轻松，PHP代码也更加优雅。但是PHP开发也经常和javascript，css，html等打交道，虽然Sublime Text本身也对他们友好，但是有以下PHP开发Sublime必备插件就更好了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>str_replace和preg_relace的用法和区别</title>
      <link>http://tanteng.me/2014/11/str_preg_relace/</link>
      <pubDate>Thu, 20 Nov 2014 08:37:06 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/11/str_preg_relace/</guid>
      <description>&lt;p&gt;str_replace和preg_relace这两个PHP系统函数都是用来“替换”的函数，str_replace主要用于字符串替换，而preg_relace顾名思义用于正则表达式替换，他们的具体用法和区别本文将举例说明。&lt;/p&gt;

&lt;h2 id=&#34;str-replace的用法&#34;&gt;str_replace的用法&lt;/h2&gt;

&lt;h3 id=&#34;1-字符串替换&#34;&gt;1.字符串替换&lt;/h3&gt;

&lt;p&gt;比如变量$a=&amp;#8217;sina,sohu,tantengvip&amp;#8217;,我要把这个$a字符串中的sina替换成qq，那么这样用str_replace函数：&lt;/p&gt;

&lt;p&gt;&lt;code lang=&#34;php&#34;&gt;$a = str_replace(&amp;lsquo;sina&amp;rsquo;,&amp;lsquo;qq&amp;rsquo;,$a);
&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP常量DIRECTORY_SEPARATOR用法</title>
      <link>http://tanteng.me/2014/11/directory_separator/</link>
      <pubDate>Wed, 12 Nov 2014 07:11:14 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/11/directory_separator/</guid>
      <description>PHP常量DIRECTORYSEPARATOR代表反斜杠，因为windows系统和linux系统的反斜杠不一样。在 Windows 中，斜线（/）和反斜线（_）都可以用作目录分隔符，在linux上路径的分隔符是&amp;#8221;/&amp;#8221;。
那么在PHP代码中什么时候要用DIRECTORY_SEPARATOR代表反斜杠呢？
比如这句话：
require_once dirname(FILE).DIRECTORY_SEPARATOR . &amp;lsquo;./../../../wp-config.php&amp;rsquo;; require_once dirname(FILE).DIRECTORY_SEPARATOR.&amp;lsquo;inc/options.php&amp;rsquo;; 
这两句PHP代码，为什么前面部分用DIRECTORY_SEPARATOR，而后面部分却用“/”呢？</description>
    </item>
    
    <item>
      <title>PHP 的“魔术常量”:__LINE__,__FILE__等</title>
      <link>http://tanteng.me/2014/11/php-line-class-dir/</link>
      <pubDate>Wed, 12 Nov 2014 06:46:42 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/11/php-line-class-dir/</guid>
      <description>&lt;p&gt;以下是在PHP开发中经常要用到的常量，称为PHP魔术常量：&lt;/p&gt;

&lt;p&gt;__LINE__ 文件中的当前行号。&lt;/p&gt;

&lt;p&gt;__FILE__ 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，__FILE__ 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。&lt;/p&gt;

&lt;p&gt;__DIR__ 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(__FILE__)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHPCMS二次开发的正确方式</title>
      <link>http://tanteng.me/2014/11/phpcms-re-develop/</link>
      <pubDate>Wed, 12 Nov 2014 03:53:25 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/11/phpcms-re-develop/</guid>
      <description>&lt;p&gt;PHPCMS二次开发如何不影响程序升级？因为对源程序进行修改之后，PHPCMS 的程序升级，新程序发布的时候，我们不方便进行升级，直接覆盖会覆盖掉我们的修改。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP魔术方法：toString</title>
      <link>http://tanteng.me/2014/10/php-tostring/</link>
      <pubDate>Wed, 29 Oct 2014 09:32:49 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/10/php-tostring/</guid>
      <description>&lt;p&gt;PHP的魔术方法toString，可以直接echo这个实例输出字符串，示例如下：&lt;/p&gt;

&lt;p&gt;&lt;code class=&#34;lang:php decode:true &#34;&gt;class haha
{
    public function __toString()
    {
        return $this-&amp;gt;test();
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected function test()
{
    return &#39;hehe&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;$aa = new haha();
echo $aa;exit;//注意，只有echo的时候才会输出字符串，如果var_dump还是打印这个示例的结构。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打印结果：hehe&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP函数:fopen,filesize,fread,fclose</title>
      <link>http://tanteng.me/2014/03/php-fopen-filesize-fread-fclose/</link>
      <pubDate>Sun, 09 Mar 2014 06:07:32 +0000</pubDate>
      
      <guid>http://tanteng.me/2014/03/php-fopen-filesize-fread-fclose/</guid>
      <description>PHP操作文件常用函数：fopen打开一个文件句柄，filesize读取文件大小，fread读取文件，fclose关闭文件操作句柄。
$file = fopen(FILE,&amp;lsquo;r&amp;rsquo;); $file_data = fread( $file, filesize(FILE) ); fclose($file); var_dump($file_data);
程序示例是读取自身，并输出全部。</description>
    </item>
    
    <item>
      <title>PHP反射类ReflectionClass和ReflectionObject</title>
      <link>http://tanteng.me/2013/11/php-reflectionclass-object/</link>
      <pubDate>Tue, 12 Nov 2013 05:16:10 +0000</pubDate>
      
      <guid>http://tanteng.me/2013/11/php-reflectionclass-object/</guid>
      <description>&lt;p&gt;PHP中的反射类，用来分析php程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。&lt;/p&gt;

&lt;p&gt;看一个这样的问题，php类的成员变量没有在类中声明，而是在函数中声明，有什么不同？&lt;/p&gt;

&lt;p&gt;&lt;code lang=&#34;php&#34;&gt;class test{
    private $name;
    private $sex;
    function __construct(){
        $this-&amp;gt;aaa=&amp;lsquo;aaa&amp;rsquo;;
    }
}&lt;/p&gt;

&lt;p&gt;$test=new test();&lt;/p&gt;

&lt;p&gt;$reflect=new ReflectionClass($test);
$pro=$reflect-&amp;gt;getDefaultProperties();
print_r($pro);//打印结果：Array ( [name] =&amp;gt; [sex] =&amp;gt; )&lt;/p&gt;

&lt;p&gt;echo $test-&amp;gt;aaa;//打印结果：aaa
&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用navicat导入sql大文件</title>
      <link>http://tanteng.me/2013/09/navicat-sql/</link>
      <pubDate>Thu, 05 Sep 2013 16:21:06 +0000</pubDate>
      
      <guid>http://tanteng.me/2013/09/navicat-sql/</guid>
      <description>&lt;p&gt;我在SAE上用自带的Deferred Jobs工具把我的wordpress博客数据库导出来了，sql格式的，保证完整。我用本机navicat新建了一个数据库，编码都是utf8，然后运行sql文件导入，每次运行一会儿就卡住了，只能导入一小部分。&lt;/p&gt;

&lt;p&gt;我用同样的方法导入sae其他的应用的sql文件，都是正常的。&lt;/p&gt;

&lt;p&gt;报错截图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;attachment-full&#34; src=&#34;http://tanteng-wordpress.stor.sinaapp.com/uploads/2013/09/201304181305293855.pngpsid1&#34; alt=&#34;201304181305293855&#34; width=&#34;408&#34; height=&#34;354&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP的序列化和json以及区别</title>
      <link>http://tanteng.me/2013/04/php-serialize-json/</link>
      <pubDate>Tue, 16 Apr 2013 06:12:56 +0000</pubDate>
      
      <guid>http://tanteng.me/2013/04/php-serialize-json/</guid>
      <description>&lt;h3 id=&#34;序列化和反序列化&#34;&gt;序列化和反序列化&lt;/h3&gt;

&lt;p&gt;序列化是将变量转换为可保存或传输的字符串的过程；反序列化就是在适当的时候把这个字符串再转化成原来的变量使用。这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。&lt;/p&gt;

&lt;p&gt;&lt;code lang=&#34;php&#34;&gt;&amp;lt;?php
$a = array(&amp;lsquo;a&amp;rsquo; =&amp;gt; &amp;lsquo;Apple&amp;rsquo; ,&amp;lsquo;b&amp;rsquo; =&amp;gt; &amp;lsquo;banana&amp;rsquo; , &amp;lsquo;c&amp;rsquo; =&amp;gt; &amp;lsquo;Coconut&amp;rsquo;);
//序列化数组
$s = serialize($a);
echo $s;
//输出结果：a:3:{s:1:&amp;ldquo;a&amp;rdquo;;s:5:&amp;ldquo;Apple&amp;rdquo;;s:1:&amp;ldquo;b&amp;rdquo;;s:6:&amp;ldquo;banana&amp;rdquo;;s:1:&amp;ldquo;c&amp;rdquo;;s:7:&amp;ldquo;Coconut&amp;rdquo;;}
echo &amp;lsquo;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&amp;rsquo;;
//反序列化
$o = unserialize($s);
print_r($o);
//输出结果 Array ( [a] =&amp;gt; Apple [b] =&amp;gt; banana [c] =&amp;gt; Coconut )
?&amp;gt;
&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>已知f(1)=2;f(2)=3;f(n)=f(n-1)&#43;f(n-2);用递归和非递归方法计算F($n)的值</title>
      <link>http://tanteng.me/2013/03/di-gui/</link>
      <pubDate>Fri, 15 Mar 2013 15:29:18 +0000</pubDate>
      
      <guid>http://tanteng.me/2013/03/di-gui/</guid>
      <description>&lt;p&gt;有一道题是这样的：f(1)=2;f(2)=3;f(n)=f(n-1)+f(n-2),写一个foo($num)方法。采用递归和非递归两种方式，计算出值。&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.递归方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code lang=&#34;php&#34;&gt;&amp;lt;?php
function foo($num){
    if ($num&amp;gt;0){
        if($num==1){
            return 2;
        }
        elseif ($num==2){
            return 3;
        }
        else{
            return foo($num-1)+foo($num-2);
        }
    }
}&lt;/p&gt;

&lt;p&gt;echo foo(5);
&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP PDOStatement:bindParam的一个陷阱</title>
      <link>http://tanteng.me/2013/03/pdo-statement-bindparam/</link>
      <pubDate>Sun, 03 Mar 2013 09:51:34 +0000</pubDate>
      
      <guid>http://tanteng.me/2013/03/pdo-statement-bindparam/</guid>
      <description>&lt;p&gt;废话不多说, 直接看代码:&lt;/p&gt;

&lt;p&gt;&lt;code lang=&#34;php&#34;&gt;&amp;lt;?php
$dbh = new PDO(&amp;lsquo;mysql:host=localhost;dbname=test&amp;rsquo;, &amp;ldquo;test&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;$query = &amp;lt;&amp;lt;&lt;QUERY
  INSERT INTO `user` (`username`, `password`) VALUES (:username, :password);
QUERY;
$statement = $dbh-&gt;prepare($query);&lt;/p&gt;

&lt;p&gt;$bind_params = array(&amp;rsquo;:username&amp;rsquo; =&amp;gt; &amp;ldquo;laruence&amp;rdquo;, &amp;lsquo;:password&amp;rsquo; =&amp;gt; &amp;ldquo;weibo&amp;rdquo;);
foreach( $bind_params as $key =&amp;gt; $value ){
    $statement-&amp;gt;bindParam($key, $value);
}
$statement-&amp;gt;execute();
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;请问, 最终执行的SQL语句是什么, 上面的代码是否有什么问题?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>php当中的memcache应用</title>
      <link>http://tanteng.me/2013/03/php-memcache/</link>
      <pubDate>Sun, 03 Mar 2013 09:13:01 +0000</pubDate>
      
      <guid>http://tanteng.me/2013/03/php-memcache/</guid>
      <description>&lt;p&gt;&lt;strong&gt;安装memcached扩展的方法：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;解压Memcached_1.2.5文档，cmd下执行memcached.exe -d -install&lt;/p&gt;

&lt;p&gt;将php5.3_vc6_memcachedll文档解压，将php_memcache.dll文件复制到php安装目录的ext文件目录中。&lt;/p&gt;

&lt;p&gt;然后在php.ini 当中填上这句话：extension=&amp;#8221;php_memcache.dll&amp;#8221;&lt;/p&gt;

&lt;p&gt;在phpinfo（）下查看，是否引用了memcache扩展。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>php的webservice示例</title>
      <link>http://tanteng.me/2013/03/php-webservice/</link>
      <pubDate>Sat, 02 Mar 2013 05:18:03 +0000</pubDate>
      
      <guid>http://tanteng.me/2013/03/php-webservice/</guid>
      <description>&lt;p&gt;首先大家要简单了解了何谓webservice，接下来就做两个非常简单的例子，webservice还是逃不开server端与client端。&lt;/p&gt;

&lt;p&gt;我测试的环境为：apache2.2.11 php5.2.10&lt;/p&gt;

&lt;p&gt;做这个测试之前，要确认你的php配置文件中已经将soap扩展打开，即extension=php_soap.dll;&lt;/p&gt;

&lt;p&gt;OK 现在我们来体验webservice&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>数据库UNSIGNED属性</title>
      <link>http://tanteng.me/2013/03/unsigned/</link>
      <pubDate>Fri, 01 Mar 2013 13:42:40 +0000</pubDate>
      
      <guid>http://tanteng.me/2013/03/unsigned/</guid>
      <description>unsigned一般是无符号的意思，比如unsigned int就是无符号整数的意思，一般有符号数的最高位是符号位，表示数据的正负，不表示大小，而无符号数的最高位是表示数据的大小，这样无符号数表示的数据范围要比有符号数大一倍
这里的id一般表示序号，所以设置为unsigned属性，这样的设计更科学合理。</description>
    </item>
    
    <item>
      <title>数据库字段类型Enum（枚举）和Set（集合）的区别（转）</title>
      <link>http://tanteng.me/2012/12/enum-set/</link>
      <pubDate>Thu, 20 Dec 2012 02:03:16 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/12/enum-set/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Enum枚举，Set集合。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ENUM和SET都是比较特殊的字符串数据列类型，它们的取值范围是一个预先定义好的列表。ENUM或SET数据列的取值只能从这个列表中进行选择。ENUM和SET的主要区别是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;ENUM只能取单值&lt;/em&gt;&lt;/strong&gt;，它的数据列表是一个枚举集合。它的合法取值列表最多允许有65535个成员。例如：ENUM(&amp;#8220;N&amp;#8221;,&amp;#8221;Y&amp;#8221;)表示，该数据列的取值要么是&amp;#8221;Y&amp;#8221;，要么就是&amp;#8221;N&amp;#8221;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;SET可取多值&lt;/em&gt;&lt;/strong&gt;。它的合法取值列表最多允许有64个成员。空字符串也是一个合法的SET值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>php中数组存入cookie的方法</title>
      <link>http://tanteng.me/2012/12/php-save-cookie/</link>
      <pubDate>Wed, 19 Dec 2012 09:32:52 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/12/php-save-cookie/</guid>
      <description>&lt;p&gt;cookie默认不能存数组，所以要采取另外的方法将数组存入cookie中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法一：先用serialize序列化数组，再存入COOKIE，读出来时用unserialize得到原来的数组&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code lang=&#34;php&#34;&gt;//存入&lt;br /&gt;
$arr = array(1,2,3);&lt;br /&gt;
$arr_str = serialize($arr);&lt;br /&gt;
setcookie(&amp;ldquo;a&amp;rdquo;,$arr_str);&lt;/p&gt;

&lt;p&gt;//取出&lt;br /&gt;
$arr_str = $_COOKIE[&amp;lsquo;a&amp;rsquo;];&lt;br /&gt;
$arr = unserialize($arr_str);
&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Navicat10.x注册码</title>
      <link>http://tanteng.me/2012/12/navica-10/</link>
      <pubDate>Wed, 19 Dec 2012 01:29:20 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/12/navica-10/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Navicat10.x注册码：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;NAVD-IO5R-4VGM-TIZD&lt;/p&gt;

&lt;p&gt;NAVL-RK72-URYA-CINR&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ThinkPHP的RBAC（基于角色权限控制）详解</title>
      <link>http://tanteng.me/2012/11/thinkphp-rbac/</link>
      <pubDate>Sun, 25 Nov 2012 07:15:58 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/11/thinkphp-rbac/</guid>
      <description>&lt;h1 id=&#34;一-什么是rbac&#34;&gt;一、什么是RBAC&lt;/h1&gt;

&lt;p&gt;基于角色的访问控制（Role-Based Access Control）作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。&lt;/p&gt;

&lt;p&gt;在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。&lt;/p&gt;

&lt;p&gt;在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>thinkphp的sql优化原则</title>
      <link>http://tanteng.me/2012/11/thinkphp-sql/</link>
      <pubDate>Sat, 17 Nov 2012 16:28:14 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/11/thinkphp-sql/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这不仅仅是针对thinkphp的，也可以针对所有mysql数据库的sql优化。摘自thinkphp官方手册的一篇文章。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常网站的性能瓶颈在数据库查询，如果你希望你的网站在一定阶段之内保持稳定，优化你的SQL和数据库是非常必要的一个优化环节。优化数据库是一个很大的话题，这里只是摘要一些比较关键的优化参考建议，并且需要具体分析项目的情况才能给出最合理的优化建议，所以具体的优化建议你应该咨询你公司的架构师或者DBA。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>php 对一组单词进行所有可能情况的排列组合</title>
      <link>http://tanteng.me/2012/11/php-zuhe/</link>
      <pubDate>Sun, 04 Nov 2012 06:20:50 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/11/php-zuhe/</guid>
      <description>&lt;p&gt;有一个数组每个元素是长度不确定的单词：&lt;/p&gt;

&lt;div id=&#34;code_block_0&#34;&gt;
  &lt;code lang=&#34;php&#34;&gt;$words = array(&#39;china&#39;,&#39;mother&#39;,&#39;father&#39;,&#39;hello&#39;,&#39;welcome&#39;);&lt;/code&gt;
  
  &lt;div title=&#34;复制代码&#34;&gt;
    这个数组元素个数不确定，寻求用php打印这些元素的所有排列组合算法 &lt;strong&gt;最好能控制组合长度，比如getCombines($words,$len=0)，这个$len就是控制组合有几个元素组成的，如果为0则打印所有组合&lt;/strong&gt;
  &lt;/div&gt;
&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>使用substr函数来实现str_replace的功能</title>
      <link>http://tanteng.me/2012/11/substr_str_replace/</link>
      <pubDate>Sat, 03 Nov 2012 13:40:01 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/11/substr_str_replace/</guid>
      <description>&lt;p&gt;要求不使用substr函数来实现str_replace的功能，如何来做呢？&lt;/p&gt;

&lt;p&gt;下面是一个使用substr的版本，思路供参考。&lt;/p&gt;

&lt;p&gt;&lt;code lang=&#34;php&#34;&gt;function str_replace($search=&amp;ldquo;, $replace=&amp;rdquo;, $subject=&amp;ldquo;){
    $search_length = strlen($search);
    $replace_length = strlen($replace);
    $subject_length = strlen($subject);
    if($search_length==0) return $subject;
    if($subject_length==0) return &amp;ldquo;;
    if($search_length &amp;gt; $subject_length) return $subject;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for($i=0;$i&amp;amp;lt;$subject_length; $i++){
    if(substr($subject, $i, $search_length)==$search){
        $subject = substr($subject, 0, $i).$replace.substr($subject, $i+$search_length);
        $i += $replace_length;
    }
}
return $subject;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用php scandir函数遍历文件夹目录和所有文件</title>
      <link>http://tanteng.me/2012/11/php-scandir/</link>
      <pubDate>Sat, 03 Nov 2012 08:30:22 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/11/php-scandir/</guid>
      <description>使用php scandir函数遍历文件夹目录和所有文件
&amp;lt;?php $dir = &amp;ldquo;.&amp;rdquo;; //当前目录 list_file($dir);
function list_file($dir){ $list = scandir($dir); // 得到该文件下的所有文件和文件夹 foreach($list as $file){//遍历 $file_location=$dir.&amp;ldquo;/&amp;rdquo;.$file;//生成路径 if(is_dir($file_location) &amp;#038;&amp;#038; $file!=&amp;ldquo;.&amp;rdquo; &amp;#038;&amp;#038;$file!=&amp;ldquo;..&amp;rdquo;){ //判断是不是文件夹 echo &amp;ldquo;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;sign in $file_location&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ldquo;; list_file($file_location); //继续遍历 } echo &amp;ldquo;&amp;rdquo;; } } ?&amp;gt; 
以前的写法：
&amp;lt;?php /** * Get an array that represents directory tree * @param string $directory Directory path * @param bool $recursive Include sub directories * @param bool $listDirs Include directories on listing * @param bool $listFiles Include files on listing * @param regex $exclude Exclude paths that matches this regex */ function directoryToArray($directory, $recursive = true, $listDirs = false, $listFiles = true, $exclude = &amp;ldquo;) { $arrayItems = array(); $skipByExclude = false; $handle = opendir($directory); if ($handle) { while (false !</description>
    </item>
    
    <item>
      <title>优化mysql数据库的方法</title>
      <link>http://tanteng.me/2012/10/optimize-mysql/</link>
      <pubDate>Mon, 15 Oct 2012 06:40:05 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/10/optimize-mysql/</guid>
      <description>&lt;p&gt;(1).数据库设计方面,这是DBA和Architect的责任,设计结构良好的数据库,必要的时候,去正规化(英文是这个:denormalize,中文翻译成啥我不知道),允许部分数据冗余,避免JOIN操作,以提高查询效率&lt;/p&gt;

&lt;p&gt;(2).系统架构设计方面,表散列,把海量数据散列到几个不同的表里面.快慢表,快表只留最新数据,慢表是历史存档.集群,主服务器Read &amp;amp; write,从服务器read only,或者N台服务器,各机器互为Master&lt;/p&gt;

&lt;p&gt;(3).(1)和(2)超越PHP Programmer的要求了,会更好,不会没关系.检查有没有少加索引&lt;/p&gt;

&lt;p&gt;(4).写高效的SQL语句,看看有没有写低效的SQL语句,比如生成笛卡尔积的全连接啊,大量的Group By和order by,没有limit等等.必要的时候,把数据库逻辑封装到DBMS端的存储过程里面.缓存查询结果,explain每一个sql语句&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>mysql数据库建立索引的好处和代价</title>
      <link>http://tanteng.me/2012/10/mysql-index/</link>
      <pubDate>Sat, 13 Oct 2012 08:34:43 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/10/mysql-index/</guid>
      <description>&lt;p&gt;说起提高数据库性能，索引是最物美价廉的东西了。不用加内存，不用改程序，不用调sql，只要执行个正确的’create index’，查询速度就可能提高百倍千倍，这可真有诱惑力。可是天下没有免费的午餐，&lt;strong&gt;查询速度的提高是以插入、更新、删除的速度为代价的，这些写操作，增加了大量的I/O。&lt;/strong&gt;由于索引的存储结构不同于表的存储，一个表的索引所占空间比数据所占空间还大的情况经常发生。&lt;/p&gt;

&lt;p&gt;这意味着我们在写数据库的时候做了很多额外的工作，而这个工作只是为了提高读的效率。因此，我们建立一个索引，必须保证这个索引不会“亏本”。&lt;/p&gt;

&lt;p&gt;**&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>php合并数组的两种方法：&#43;和array_merge()的区别</title>
      <link>http://tanteng.me/2012/10/array_merge/</link>
      <pubDate>Thu, 11 Oct 2012 02:57:13 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/10/array_merge/</guid>
      <description>&lt;p&gt;PHP中两个数组合并可以使用+或者array_merge，但之间还是有区别的，而且这些区别如果了解不清楚项目中会要命的！&lt;/p&gt;

&lt;p&gt;主要区别是两个或者多个数组中如果出现相同键名，键名分为字符串或者数字，需要注意&lt;/p&gt;

&lt;p&gt;1）键名为数字时，array_merge()不会覆盖掉原来的值，但＋合并数组则会把最先出现的值作为最终结果返回，而把后面的数组拥有相同键名的那些值“抛弃”掉（不是覆盖）&lt;/p&gt;

&lt;p&gt;2）键名为字符时，＋仍然把最先出现的值作为最终结果返回，而把后面的数组拥有相同键名的那些值“抛弃”掉，但array_merge()此时会覆盖掉前面相同键名的值&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MYSQL中myisam和innodb引擎的区别</title>
      <link>http://tanteng.me/2012/10/mysql-myisam-innodb/</link>
      <pubDate>Thu, 11 Oct 2012 02:39:04 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/10/mysql-myisam-innodb/</guid>
      <description>&lt;p&gt;MyISAM 是MySQL中默认的存储引擎，一般来说不是有太多人关心这个东西。决定使用什么样的存储引擎是一个很tricky的事情，但是还是值我们去研究一下，这里的文章只考虑 MyISAM 和InnoDB这两个，因为这两个是最常见的。&lt;/p&gt;

&lt;p&gt;讲讲你对mysql myisam和innodb的认识。然后你认为他们的区别在那里？为什么？&lt;/p&gt;

&lt;p&gt;**&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>提高php执行效率的10条编程习惯</title>
      <link>http://tanteng.me/2012/10/php-efficiency/</link>
      <pubDate>Fri, 05 Oct 2012 03:00:40 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/10/php-efficiency/</guid>
      <description>&lt;p&gt;&lt;strong&gt;1、使用单引号括起来的字符串&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当使用双引号来括字符串时，PHP解释器会对其进行变量替换、转义等操作，如“ ”。如果你只想输出一个基本的字符串，就用单引号吧，这样会节省一些资源。当然，如果你需要进行变量替换的，那就必须用双引号了，但其他情况下还是用单引号吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、字符串的输出&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你认为以下哪一条语句的运行速度最快?&lt;/p&gt;

&lt;p&gt;print “Hi my name is $a. I am $b”;&lt;/p&gt;

&lt;p&gt;echo “Hi my name is $a. I am $b”;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>php超级全局变量总结</title>
      <link>http://tanteng.me/2012/10/php-super-global/</link>
      <pubDate>Tue, 02 Oct 2012 09:19:44 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/10/php-super-global/</guid>
      <description>&lt;p&gt;PHP有9个预定义变量数组，分别总结如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、$_SERVER&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$_SERVER超级全局变量包含由web服务器创建的信息，它提供了服务器和客户配置及当前请求环境的有关信息。根据服务器不同，$_SERVER中的变量值和变量个数会有差别，不过一般都可以找到CGI1.1规范中定义的变量。其中包括：&lt;/p&gt;

&lt;p&gt;$_SERVER[ &amp;#8216;HTTP_REFERER&amp;#8217; ] ; 引导用户到达当前位置的页面的URL ；&lt;/p&gt;

&lt;p&gt;$_SERVER[ &amp;#8216;REMOTE_ADDR‘ ] ; 客户IP地址 ；&lt;/p&gt;

&lt;p&gt;$_SERVER[ ’REQUEST_URI‘ ] ; URL的路径部分。如果URL是 &lt;a href=&#34;http://tanteng.sinaapp.com/blog/apache/index.html&#34;&gt;http://tanteng.sinaapp.com/blog/apache/index.html&lt;/a&gt; ，那么URI就是/blog/apache/index.html 。&lt;/p&gt;

&lt;p&gt;$_SERVER[ &amp;#8216;HTTP_USER_AGENT&amp;#8217; ] ; 客户的用户代理，一般会提供操作系统和浏览器的有关信息。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP：PDO prepare预处理</title>
      <link>http://tanteng.me/2012/09/php-pdo-prepare/</link>
      <pubDate>Sun, 30 Sep 2012 04:03:39 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/09/php-pdo-prepare/</guid>
      <description>&lt;p&gt;许多成熟的数据库都支持预处理语句（Prepared Statements)的概念。它们是什么东西？你可以把它们想成是一种编译过的要执行的SQL语句模板，可以使用不同的变量参数定制它。预处理语句具有两个主要的优点：&lt;/p&gt;

&lt;p&gt;查询只需要被解析（或准备）一次，但可以使用相同或不同的参数执行多次。当查询准备好（Prepared）之后，数据库就会分析，编译并优化它要执行查询的计划。对于复杂查询来说，如果你要重复执行许多次有不同参数的但结构相同的查询，这个过程会占用大量的时间，使得你的应用变慢。通过使用一个预处理语句你就可以避免重复分析、编译、优化的环节。简单来说，预处理语句使用更少的资源，执行速度也就更快。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HTTP状态码200、301、403、404、500等</title>
      <link>http://tanteng.me/2012/09/http-200-301-403-404-500/</link>
      <pubDate>Wed, 26 Sep 2012 15:41:36 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/09/http-200-301-403-404-500/</guid>
      <description>&lt;p&gt;HTTP状态码以及其含义，web前端面试常考，必须掌握。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一些常见的状态码为&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;200 &amp;#8211; 服务器成功返回网页&lt;/p&gt;

&lt;p&gt;404 &amp;#8211; 请求的网页不存在&lt;/p&gt;

&lt;p&gt;503 &amp;#8211; 服务器超时&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>深入理解 PHP 中 session 和 cookies 的联系</title>
      <link>http://tanteng.me/2012/09/php-session-cookies/</link>
      <pubDate>Wed, 26 Sep 2012 01:46:43 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/09/php-session-cookies/</guid>
      <description>&lt;p&gt;1. session概念&lt;/p&gt;

&lt;p&gt;2. http协议与状态保持&lt;/p&gt;

&lt;p&gt;3. 理解cookie&lt;/p&gt;

&lt;p&gt;4. php中session的生成机制&lt;/p&gt;

&lt;p&gt;5. php中session的过期回收机制&lt;/p&gt;

&lt;p&gt;6. php中session的客户端存储机制&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>详解php的魔术方法__get()和__set()</title>
      <link>http://tanteng.me/2012/09/php_set_get/</link>
      <pubDate>Fri, 14 Sep 2012 04:18:42 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/09/php_set_get/</guid>
      <description>&lt;p&gt;先看看php官方文档的解释:&lt;/p&gt;

&lt;p&gt;__set() is run when writing data to inaccessible properties.&lt;/p&gt;

&lt;p&gt;__get() is utilized for reading data from inaccessible properties.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>php引用计数器进行垃圾收集机制</title>
      <link>http://tanteng.me/2012/09/php-ref-counter/</link>
      <pubDate>Thu, 13 Sep 2012 15:08:26 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/09/php-ref-counter/</guid>
      <description>&lt;p&gt;PHP 有一个非常简单的垃圾收集器，它实际上将对不再位于内存范围（scope）中的对象进行垃圾收集。垃圾收集的内部方式是使用一个引用计数器，因此当计数器达到 0 时（意味着对该对象的引用都不可用），对象将被当作垃圾收集并从内存中删除。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP 数组相加：array(“a”)&#43;array(“b”)结果还是array(“a”)</title>
      <link>http://tanteng.me/2012/09/array-adding/</link>
      <pubDate>Thu, 13 Sep 2012 04:10:12 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/09/array-adding/</guid>
      <description>&lt;p&gt;在网上看到一道题：&lt;/p&gt;

&lt;p&gt;array(&amp;#8220;a&amp;#8221;)+array(&amp;#8220;b&amp;#8221;)的结果是___&lt;/p&gt;

&lt;p&gt;A.array(&amp;#8220;a&amp;#8221;,&amp;#8221;b&amp;#8221;)&lt;/p&gt;

&lt;p&gt;B.array(&amp;#8220;b&amp;#8221;,&amp;#8221;a&amp;#8221;)&lt;/p&gt;

&lt;p&gt;C.array(&amp;#8220;b&amp;#8221;)&lt;/p&gt;

&lt;p&gt;D.array(&amp;#8220;a&amp;#8221;)&lt;/p&gt;

&lt;p&gt;答案：D&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>php递归统计多位数组个数count（$array，1）</title>
      <link>http://tanteng.me/2012/09/php-count-array/</link>
      <pubDate>Mon, 10 Sep 2012 14:42:10 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/09/php-count-array/</guid>
      <description>&lt;p&gt;下面程序运行结果为（）&lt;/p&gt;

&lt;p&gt;&lt;code lang=&#34;php&#34;&gt;$numb=array(array(10,15,30),array(10,15,30),array(10,15,30));
echo count($numb,1);
&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP对象在内存堆栈中的分配</title>
      <link>http://tanteng.me/2012/09/stack-php/</link>
      <pubDate>Sun, 09 Sep 2012 07:54:05 +0000</pubDate>
      
      <guid>http://tanteng.me/2012/09/stack-php/</guid>
      <description>&lt;p&gt;对象在PHP里面和整型、浮点型一样，也是一种数据类，都是存储不同类型数据用的， 在运行的时候都要加载到内存中去用，那么对象在内存里面是怎么体现的呢？内存从逻辑上说大体上是分为4段，&lt;strong&gt;栈空间段、堆空间段、代码段、初始化静态段&lt;/strong&gt;，程序里面不同的声明放在不同的内存段里面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据段&lt;/strong&gt;（data segment）通常是指用来存放程序中已初始化且不为0的全局变量如：静态变量和常量&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码段&lt;/strong&gt;（code segment / text segment）通常是指用来存放程序执行代码的一块内存区域，比如函数和方法&lt;/p&gt;

&lt;p&gt;**&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>